<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>BENULL</title>
  
  <subtitle>tomorrow is another day</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-08-02T14:58:58.613Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>BENULL</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>读书笔记——消失的13级台阶</title>
    <link href="http://yoursite.com/2021/07/25/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E6%B6%88%E5%A4%B1%E7%9A%8413%E7%BA%A7%E5%8F%B0%E9%98%B6/"/>
    <id>http://yoursite.com/2021/07/25/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E6%B6%88%E5%A4%B1%E7%9A%8413%E7%BA%A7%E5%8F%B0%E9%98%B6/</id>
    <published>2021-07-25T14:58:22.000Z</published>
    <updated>2021-08-02T14:58:58.613Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://m.media-amazon.com/images/I/51ckcjFtx4S.jpg" align="center"></p><blockquote><p>作者: [日] 高野和明<br>出版社: 上海文艺出版社<br>出品方: 读客文化<br>副标题: 读客外国小说文库<br>原作名: 13階段<br>译者: 赵建勋<br>ISBN: 9787532175512</p></blockquote><div class="note info"><p>210725</p></div><blockquote class="blockquote-center"><p>刑法史上有两种理论：一种是报应刑论，主张刑罚是对犯罪者的报复；另一种是目的刑论，以教育改造犯罪者、消除社会威胁为主。</p></blockquote><blockquote class="blockquote-center"><p>为什么是三个按钮呢？这是为了让三个死刑执行官分不清楚到底是谁把死刑犯送上西天的。</p></blockquote><blockquote class="blockquote-center"><p>如果这个社会认可私刑，社会就会陷于无秩序状态。因此，必须由第三者，也就是国家机器行使刑罚权，来代替被害人亲属做他们想做的事。</p></blockquote><blockquote class="blockquote-center"><p>以报应刑论为基础的死刑判决制度，引出了悔过之心这个教育刑论希望达到的目标，这种现象难道不是一种绝妙的讽刺吗？</p></blockquote><blockquote class="blockquote-center"><p>维持死刑制度的既不是国民也不是国家，而是杀人犯自己!</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://m.media-amazon.com/images/I/51ckcjFtx4S.jpg&quot; align=&quot;center&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;作者: [日] 高野和明&lt;br&gt;出版社: 上海文艺出版社&lt;br&gt;出品方: 读
      
    
    </summary>
    
    
      <category term="Reading" scheme="http://yoursite.com/categories/Reading/"/>
    
    
      <category term="Reading" scheme="http://yoursite.com/tags/Reading/"/>
    
  </entry>
  
  <entry>
    <title>记一次大数据挑战赛</title>
    <link href="http://yoursite.com/2021/06/30/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8C%91%E6%88%98%E8%B5%9B/"/>
    <id>http://yoursite.com/2021/06/30/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8C%91%E6%88%98%E8%B5%9B/</id>
    <published>2021-06-30T13:38:29.000Z</published>
    <updated>2021-06-30T13:38:01.693Z</updated>
    
    <content type="html"><![CDATA[<h1 id="记一次大数据挑战赛"><a href="#记一次大数据挑战赛" class="headerlink" title="记一次大数据挑战赛"></a>记一次大数据挑战赛</h1><blockquote><p>对于给定的一定数量到访过微信视频号“热门推荐”的用户， 根据这些用户在视频号内的历史n天的行为数据，通过算法在测试集上预测出这些用户对于不同视频内容的互动行为（包括点赞、点击头像、收藏、转发等）的发生概率。 本次比赛以多个行为预测结果的加权uAUC值进行评分</p></blockquote><p><a href="https://algo.weixin.qq.com/" target="_blank" rel="noopener">2021微信大数据挑战赛</a></p><p>第一次接触这类比赛，成绩不大行，记录一下自己实验到的东西，并不一定对</p><p>因为第一次，对于什么特征在这类任务中比较重要也不清楚，造的特征主要参考了大佬的分享<a href="https://mp.weixin.qq.com/s/yE5yThqZ8R9v4EIxlr3bsA" target="_blank" rel="noopener">微信视频号推荐算法解题思路</a></p><p>nn模型用的是deepctr的deepfm模型，树模型用的lightgbm</p><ul><li>对nn尝试过各类采样方法都没有全量训练效果好</li><li>deepfm的dnn层数[128,128,128]好像就够用了</li><li>使用adam比adagrad好</li><li>deepfm、xdeepfm、autoint效果差不多</li><li>batchsize尝试中1024结果比较好</li><li>deepfm中统计特征的作用不大，加上feed embedding后有很大的提升</li><li>对tags和keyword使用word2vec好像没有multilable降维后好用</li><li>user相关的特征比较好用，feed的特征作用不是很明显</li><li><p>nn多折融合有明显的提升，融合树模型和nn也有大的提升</p></li><li><p>没有利用到任务间的相关性，没来的急试试mmoe</p></li></ul><p>想看看大佬是怎么做的，等着大佬分享</p><p><strong>数据集下载</strong></p><p>链接: <a href="https://pan.baidu.com/s/1SPmyv7zoHhDVm57N0OgUzA" target="_blank" rel="noopener">https://pan.baidu.com/s/1SPmyv7zoHhDVm57N0OgUzA</a></p><p>提取码: 8g95 </p><p><a href="https://github.com/BENULL/WeChatBigDataChallenge2021" target="_blank" rel="noopener"><strong>代码地址</strong></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;记一次大数据挑战赛&quot;&gt;&lt;a href=&quot;#记一次大数据挑战赛&quot; class=&quot;headerlink&quot; title=&quot;记一次大数据挑战赛&quot;&gt;&lt;/a&gt;记一次大数据挑战赛&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;对于给定的一定数量到访过微信视频号“热门推荐”的用户， 根
      
    
    </summary>
    
    
      <category term="BigData" scheme="http://yoursite.com/categories/BigData/"/>
    
    
      <category term="MIX" scheme="http://yoursite.com/tags/MIX/"/>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="BigData" scheme="http://yoursite.com/tags/BigData/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记——被讨厌的勇气</title>
    <link href="http://yoursite.com/2021/05/28/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E8%A2%AB%E8%AE%A8%E5%8E%8C%E7%9A%84%E5%8B%87%E6%B0%94/"/>
    <id>http://yoursite.com/2021/05/28/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E8%A2%AB%E8%AE%A8%E5%8E%8C%E7%9A%84%E5%8B%87%E6%B0%94/</id>
    <published>2021-05-28T08:38:22.000Z</published>
    <updated>2021-08-03T08:17:13.691Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://m.media-amazon.com/images/I/41BuHsbPZBL.jpg" align="center"></p><blockquote><p>作者: <a href="https://book.douban.com/search/岸见一郎" target="_blank" rel="noopener">岸见一郎</a> / <a href="https://book.douban.com/search/古贺史健" target="_blank" rel="noopener">古贺史健</a><br>出版社: 机械工业出版社<br>副标题: “自我启发之父”阿德勒的哲学课<br>原作名: 嫌われる勇気：自己啓発の源流「アドラー」の教え<br>译者: <a href="https://book.douban.com/search/渠海霞" target="_blank" rel="noopener">渠海霞</a><br>出版年: 2015-3-1<br>ISBN: 9787111495482</p></blockquote><div class="note info"><p>210515</p></div><p><strong>⭕️ “生活给我们各种束缚，表面上看起来，这些束缚是时间的、金钱的、人际关系的，但实际上，这些束缚是心灵的。阿德勒的整个理论体系，都在试图把人从这种束缚中解脱出来，让人重获心灵自由”</strong></p><p><strong>⭕️ 保持年轻的心态，令人生“只若初见”</strong></p><p><strong>⭕️  “人并不是住在客观的世界，而是住在自己营造的主观世界里”</strong></p><div class="note info"><p>210516</p></div><p><strong>⭕️ 阿德勒心理学考虑的不是过去的“原因”，而是现在的“目的”。</strong></p><p><strong>⭕️ 我们给过去的经历“赋予了什么样的意义”，这直接决定了我们的生活。人生不是由别人赋予的，而是由自己选择的，是自己选择自己如何生活。</strong></p><div class="note info"><p>210519</p></div><p><strong>⭕️ “人的烦恼皆源于人际关系。”这是阿德勒心理学的一个基本概念。如果这个世界没有人际关系，如果这个宇宙中没有他人只有自己，那么一切烦恼也都将消失”</strong></p><p><strong>⭕️ “自卑情结是指把自己的自卑感当作某种借口使用的状态。具体就像“我因为学历低所以无法成功”或者“我因为长得不漂亮所以结不了婚”之类的想法。”</strong></p><p><strong>⭕️ “健全的自卑感不是来自与别人的比较，而是来自与“理想的自己”的比较。”</strong></p><p><strong>⭕️ “行为方面的目标有“自立”和“与社会和谐共处”这两点。”</strong></p><p><strong>⭕️ “工作上的人际关系可以说门槛最低。工作上的人际关系因为有着成果这一简单易懂的共通目标，即使有些不投缘也可以合作或者说必须合作；而且，因“工作”这一点结成的关系，在下班或者转行后就又可以变回他人关系”</strong></p><p><strong>⭕️ “请你这样想，如果在一起感到苦闷或者紧张，那即使是恋爱关系也不能称之为爱。当人能够感觉到“与这个人在一起可以无拘无束”的时候，才能够体会到爱。既没有自卑感也不必炫耀优越性，能够保持一种平静而自然的状态。真正的爱应该是这样的。”</strong></p><div class="note info"><p>210523</p></div><p><strong>⭕️ “认可欲求”，人际关系的烦恼都集中在这一点上。我们在活着时常需要得到他人的认可。正因为对方不是令人讨厌的“敌人”，所以才想要得到那个人的认可！对，我就是想要得到父母的认可！”</strong></p><p><strong>⭕️ “在犹太教教义中有这么一句话：“倘若自己都不为自己活出自己的人生，那还有谁会为自己而活呢？”</strong></p><p><strong>⭕️ “我的建议是这样。首先要思考一下“这是谁的课题”。然后进行课题分离——哪些是自己的课题，哪些是别人的课题，要冷静地划清界限。”</strong></p><p><strong>⭕️ “阿德勒心理学中有反常识的方面”</strong></p><p><strong>⭕️ “选择了不自由生活方式的大人看着自由活在当下的年轻人就会批判其“享乐主义”。当然，这其实是为了让自己接受不自由生活而捏造出的一种人生谎言。选择了真正自由的大人就不会说这样的话，相反还会鼓励年轻人要勇于争取自由。”</strong></p><p><strong>⭕️“不畏惧被人讨厌而是勇往直前，不随波逐流而是激流勇进，这才是对人而言的自由。”</strong></p><div class="note info"><p>210524</p></div><p><strong>⭕️ “把他人看作伙伴并能够从中感到“自己有位置”的状态，就叫共同体感觉”</strong></p><p><strong>⭕️ “共同体感觉是幸福的人际关系的最重要的指标”</strong></p><p><strong>⭕️ “请你考虑一下认可欲求的实质——他人如何关注自己、如何评价自己？又在多大程度上满足自己的欲求？受这种认可欲求束缚的人看似在看着他人，但实际上眼里却只有自己。失去了对他人的关心而只关心“我”，也就是以自我为中心。”</strong></p><p><strong>⭕️ “抱着自己位于世界中心这种信念的人很快就会失去“朋友”</strong></p><p><strong>⭕️ “例如，人怎样才能够获得“勇气”？阿德勒的见解是：人只有在能够感觉自己有价值的时候才可以获得勇气”</strong></p><div class="note info"><p>210527</p></div><p><strong>⭕️ “自我意识总是牵绊着自己、严重束缚着自己的言行。我的自我意识根本不允许自己无拘无束地行动。”</strong></p><p><strong>⭕️ “首先，真诚地接受不能交换的“这个我”，这就是自我接纳。同时，对他人寄予无条件的信赖即他者信赖。”</strong></p><p><strong>⭕️ 行为方面的目标</strong></p><ul><li><strong>自立</strong></li><li><strong>与社会和谐共处</strong></li></ul><p><strong>⭕️ 支撑这种行为的心理方面的目标</strong></p><ul><li><strong>“我有能力”的意识。</strong></li><li><strong>“人人都是我的伙伴”的意识。”</strong></li></ul><p><strong>⭕️ “具有神经质生活方式的人常常使用“大家”“总是”或者“一切”之类的词语。“大家都讨厌自己”“总是只有自己受损失”或者“一切都不对”等。如果你常常说这种一般化的词语，那就需要注意了。”</strong></p><p><strong>⭕️ “缺乏人生和谐的人就会只关注讨厌自己的那个人来判断“世界”。”</strong></p><p><strong>⭕️ “口吃为什么会很痛苦呢？阿德勒心理学认为苦恼于口吃的人只关心“自己的说话方式”，从而感到自卑和痛苦。因此，自我意识就会变得过剩，说话也会更加不顺畅。”</strong></p><p><strong>⭕️ “是的。笑话别人口吃的人只是极少数。用刚才的话说，充其量就是“10人中的1人”。并且，采取这种嘲笑态度的愚蠢的人，我们可以主动与其切断关系。但是，如果缺乏人生和谐，那就会只关注这1个人，并认为“大家都嘲笑我”。”</strong></p><p><strong>⭕️ “只考虑公司的工作，那是一种缺乏人生和谐的生活方式。”</strong></p><p><strong>⭕️ “获得贡献感的手段一旦成了“被他人认可”，最终就不得不按照他人的愿望来过自己的人生。通过认可欲求获得的贡献感没有自由。但我们人类是在选择自由的同时也在追求幸福。”</strong></p><p><strong>⭕️ “无论是希望特别优秀还是希望特别差劲，其目的都一样——引起他人的关注、脱离“普通”状态、成为“特别的存在”。这就是他们的目的。”</strong></p><p><strong>⭕️ “自我接纳就是其中的重要一步。如果你能够拥有“甘于平凡的勇气”，那么对世界的看法也会截然不同。”</strong></p><p><strong>⭕️ “想要到达目的地的人生可以称为“潜在性的人生”。与此相对，我所说的像跳舞一样的人生则可以称为“现实性的人生”。”</strong></p><p><strong>⭕️ “最重要的是“此时此刻”</strong></p><div class="note info"><p>210528</p></div><p>⭕️ <strong>“人生并不存在可以作为常识来讲的意义”</strong></p><p><strong>⭕️ “哲学真正的意义不在于“知识”而在于“热爱知识”，想要了解不了解的事物以及获得知识的过程非常重要。”</strong></p><p><strong>⭕️ “如果有人认为难以接纳阿德勒思想，那是因为这种思想是反常识观点的集大成者，而且要想理解它也需要日常生活中的实践；”</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://m.media-amazon.com/images/I/41BuHsbPZBL.jpg&quot; align=&quot;center&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;作者: &lt;a href=&quot;https://book.douban.com/s
      
    
    </summary>
    
    
      <category term="Reading" scheme="http://yoursite.com/categories/Reading/"/>
    
    
      <category term="Reading" scheme="http://yoursite.com/tags/Reading/"/>
    
  </entry>
  
  <entry>
    <title>Transformer(Attention Is All You Need)</title>
    <link href="http://yoursite.com/2021/05/16/[%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB]%20Transformer(Attention%20Is%20All%20You%20Need)/"/>
    <id>http://yoursite.com/2021/05/16/[%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB]%20Transformer(Attention%20Is%20All%20You%20Need)/</id>
    <published>2021-05-16T03:54:54.000Z</published>
    <updated>2021-05-16T03:59:49.369Z</updated>
    
    <content type="html"><![CDATA[<h1 id="论文阅读-Transformer-Attention-Is-All-You-Need"><a href="#论文阅读-Transformer-Attention-Is-All-You-Need" class="headerlink" title="[论文阅读] Transformer(Attention Is All You Need)"></a>[论文阅读] Transformer(Attention Is All You Need)</h1><blockquote><p>单位: Google</p><p>会议: NeurIPS 2017</p><p>论文地址: <a href="https://arxiv.org/abs/1706.03762" target="_blank" rel="noopener">arxiv</a></p><p>代码: <a href="https://github.com/tensorflow/tensor2tensor" target="_blank" rel="noopener">tensorflow/tensor2tensor official</a></p></blockquote><p><img src="https://img-blog.csdnimg.cn/20210516114517723.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyODE1ODA3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="Seq2Seq"><a href="#Seq2Seq" class="headerlink" title="Seq2Seq"></a>Seq2Seq</h2><p><img src="https://img-blog.csdnimg.cn/2021051611451353.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyODE1ODA3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>Encoder和Decoder在早期一般是RNN模块，后来引入了LSTM或者GRU模块，核心思想都是通过Encoder编码成一个表示向量，即上下文编码向量，然后交给Decoder来进行解码，翻译成目标语言</p><p><strong>RNN的局限</strong></p><ul><li><p>对于不同输入和输出长度，中间的上下文编码向量长度固定的，仅仅靠一个固定长度的上下文编码向量包含的信息有限</p></li><li><p>RNN 本质是一个马尔科夫决策过程无法很好地学习到全局的结构信息</p></li><li><p>难以并行化，速度慢</p></li></ul><p><strong>CNN</strong></p><p>在 FaceBook 的论文(Convolutional Sequence to Sequence Learning）中纯粹使用CNN也完成了 Seq2Seq 的学习</p><p><strong>CNN 方便并行，而且容易捕捉到一些全局的结构信息</strong></p><p>但CNN 事实上只能获取局部信息，是通过层叠来增大感受野</p><p><img src="https://img-blog.csdnimg.cn/20210516114513298.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyODE1ODA3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><strong>在Transformer中，完全抛弃了RNN和CNN等网络结构，仅仅采用Attention机制就取得了很好的效果，具有更好的质量，同时具有更高的并行性和更少的训练时间</strong></p><p>这篇主要贡献之一是<strong>它表明了内部注意力在机器翻译（甚至是一般的 Seq2Seq 任务）的序列编码上是相当重要的</strong>，而之前关于 Seq2Seq 的研究基本都只是把注意力机制用在解码端。</p><h2 id="Transformer-Architecture"><a href="#Transformer-Architecture" class="headerlink" title="Transformer Architecture"></a>Transformer Architecture</h2><p><img src="https://img-blog.csdnimg.cn/20210516114512905.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyODE1ODA3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>Transformer结构可以表示为Encoder和Decoder两个部分</p><p>Encoder和Decoder主要由Self-Attention和Feed-Forward Network两个组件构成</p><p>Self-Attention由Scaled Dot-Product Attention和Multi-Head Attention两个组件构成。</p><h2 id="Self-Attention"><a href="#Self-Attention" class="headerlink" title="Self-Attention"></a>Self-Attention</h2><p><strong>Attention</strong> <strong>机制来自于人类视觉注意力机制</strong>,人们视觉在感知东西的时候一般不会是一个场景从到头看到尾每次全部都看，而往往是根据需求观察注意特定的一部分</p><p><img src="https://img-blog.csdnimg.cn/20210516114514447.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyODE1ODA3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">注意力函数的本质可以被描述为一个查询（query）到一系列（键key-value值)对的映射</p><p>给定一个和任务相关的查询查询向量 <strong>q</strong>，通过计算与<strong>Key</strong>的注意力分布并附加在<strong>Value</strong>上，从而计算<strong>Attention Value</strong></p><p><strong>引入attention的好处</strong></p><ul><li><p>注意力允许解码器以不同程度的权重利用到编码器的所有信息</p></li><li><p>通过检查注意力分布，可以看到解码器在关注什么，可解释性</p></li></ul><p>Self-Attention的QKV来自同一个输入，也就是说在序列内部做 Attention，寻找序列内部的联系，故称为自注意力层</p><h3 id="Scaled-Dot-Product-Attention"><a href="#Scaled-Dot-Product-Attention" class="headerlink" title="Scaled Dot-Product Attention"></a>Scaled Dot-Product Attention</h3><p><img src="https://img-blog.csdnimg.cn/20210516114512994.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyODE1ODA3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><script type="math/tex; mode=display">\operatorname{Attention}(\boldsymbol{Q}, \boldsymbol{K}, \boldsymbol{V})=\operatorname{softmax}\left(\frac{\boldsymbol{Q} \boldsymbol{K}^{\top}}{\sqrt{d_{k}}}\right) \boldsymbol{V}</script><p>计算过程</p><ol><li>对每个输入单词$x^1,x^2,x^3$转化成嵌入向量</li><li>根据嵌入向量分别得到$q$，$k$，$v$三个向量</li><li>然后将$q$和所有$k$进行点乘计算得$\alpha$</li><li>通过SoftMax转换为概率分布$\hat{\alpha}$</li><li>将概率分布和所有$v$进行加权求和得到输出$b$</li></ol><p><img src="https://img-blog.csdnimg.cn/20210516114512671.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyODE1ODA3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><strong>为什么scaled?</strong></p><p>可参考<a href="https://www.zhihu.com/question/339723385" target="_blank" rel="noopener">transformer中的attention为什么scaled?</a></p><h3 id="Multi-Head-Attention"><a href="#Multi-Head-Attention" class="headerlink" title="Multi-Head Attention"></a>Multi-Head Attention</h3><p><img src="https://img-blog.csdnimg.cn/20210516114513198.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyODE1ODA3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><script type="math/tex; mode=display">\text { head }_{\mathrm{i}}=\operatorname{Attention}\left(Q W_{i}^{Q}, K W_{i}^{K}, V W_{i}^{V}\right)</script><script type="math/tex; mode=display">\left.\operatorname{MultiHead}(Q, K, V)=\text { Concat(head }_{1}, \ldots, \text { head }_{\mathrm{h}}\right) W^{O}</script><p>Multi-Head Attention相当于多个不同Scaled Dot-Product Attention的集成，以8为例子，Multi-Head Attention步骤如下：</p><ol><li><p>将数据$X$分别输入到8个不同的Scaled Dot-Product Attention中，得到8个加权后的特征矩阵$Z_{i}, i \in{1,2, \ldots, 8}$ </p></li><li><p>将8个$Z$按列拼成一个大的特征矩阵</p></li><li><p>特征矩阵经过一层全连接得到输出$Z$</p></li></ol><p>可以类比CNN中同时使用多个卷积核的作用，多头的注意力有助于网络捕捉到更丰富的信息，每个head关注的点可能不一样，可以处理不同的任务</p><h2 id="Positional-Encoding"><a href="#Positional-Encoding" class="headerlink" title="Positional  Encoding"></a>Positional  Encoding</h2><p>transformer内部没有类似RNN的循环结构，没有捕捉顺序序列的能力，无论句子结构怎么打乱，transformer都会得到类似的结果</p><p>为了解决这个问题，在编码词向量时会额外引入了位置编码向量</p><p>将每个位置编号，然后每个编号对应一个向量，通过结合位置向量和词向量，就给每个词都引入了一定的位置信息，这样 Attention 就可以分辨出不同位置的词了</p><p><img src="https://img-blog.csdnimg.cn/2021051611451387.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyODE1ODA3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><ul><li>将向量的512维度切分为奇数行和偶数行</li><li>偶数行采用sin函数编码，奇数行采用cos函数编码</li><li>然后按照原始行号拼接</li></ul><p>由于有</p><script type="math/tex; mode=display">\sin (a+\beta)=\sin \alpha \cos \beta+\cos a \sin \beta \\\cos (\alpha+\beta)=\cos a \cos \beta-\sin \alpha \sin \beta</script><p>所有的$PE<em>{pos+k}$可以用$PE</em>{pos}$线性表出，表达了相对位置信息</p><p>同样的也可以训练得到位置编码向量，但是试验结果表明相差不大，因此论文选择了直接定义，这样直接计算而不需要训练，减少了训练参数，同时允许模型将位置编码向量扩展到超过了训练集中最长序列长度的位置编码</p><h2 id="Feed-Forward-Networds"><a href="#Feed-Forward-Networds" class="headerlink" title="Feed-Forward Networds"></a>Feed-Forward Networds</h2><p>在每个子层中，Multi-Head Attention层都接了一个FFN层，先线性变换，然后ReLU非线性，再线性变换</p><script type="math/tex; mode=display">F F N(x)=\max \left(0, x W_{1}+b_{1}\right) W_{2}+b_{2}</script><p>作用将Attention结果映射到一个更大维度的特征空间</p><p>在抛弃了 LSTM 结构后，FFN 中的 ReLU成为了一个主要的能<strong>提供非线性变换的单元</strong></p><h2 id="Layer-Norm"><a href="#Layer-Norm" class="headerlink" title="Layer Norm"></a>Layer Norm</h2><p>主要的几种归一化方法</p><ul><li><p>Batch Normalization</p></li><li><p>Layer Normalization</p></li><li><p>Instance Normalization</p></li><li><p>Group Normalization</p></li></ul><p><img src="https://img-blog.csdnimg.cn/20210516114512866.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyODE1ODA3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>将输入的图像shape记为<code>[N, C, H, W]</code>，这几个方法主要的区别</p><p>BatchNorm是在batch上，对NHW做归一化，对小batchsize效果不好<br>LayerNorm在通道方向上，对CHW归一化，主要对RNN作用明显<br>InstanceNorm在图像像素上，对HW做归一化，用在风格化迁移<br>GroupNorm将channel分组，然后再做归一化</p><p><strong>Transformer为什么选用Layer Normalization呢？</strong></p><p>看了知乎上一些关于使用BN效果不好的讨论</p><p>比较同意是因为NLP数据和CV数据特性不同带来的影响，<strong>数据的相关性表现在哪个维度，决定了采用何种信息抽取方式</strong></p><p>BN是对不同样本的同一特征做操作而LN是对单个样本的不同特征做操作</p><blockquote><p>在NLP中不同batch样本的信息关联性不大，而且由于不同的句子长度不同，强行归一化会损失不同样本间的差异信息，所以就没在batch维度进行归一化，而是选择LN，只考虑的句子内部维度的归一化。</p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p><a href="https://zhuanlan.zhihu.com/p/308301901?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=765637550864871424" target="_blank" rel="noopener">3W字长文带你轻松入门视觉transformer - 知乎</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MzIwMTc4ODE0Mw==&amp;mid=2247486960&amp;idx=1&amp;sn=1b4b9d7ec7a9f40fa8a9df6b6f53bbfb&amp;chksm=96e9d270a19e5b668875392da1d1aaa28ffd0af17d44f7ee81c2754c78cc35edf2e35be2c6a1&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">一文读懂「Attention is All You Need」| 附代码实现</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/105493618" target="_blank" rel="noopener">深度学习-图解Transformer (变形金刚) - 知乎</a></p></li><li><p><a href="https://blog.csdn.net/c9Yv2cf9I06K2A9E/article/details/79739287?utm_source=blogxgwz0" target="_blank" rel="noopener">自然语言处理中的自注意力机制（Self-Attention Mechanism）_Paper weekly-CSDN博客</a></p></li><li><p><a href="https://www.zhihu.com/question/68482809" target="_blank" rel="noopener">目前主流的attention方法都有哪些？ - 知乎</a></p></li><li><p><a href="https://www.zhihu.com/search?type=content&amp;q=transformer位置编码" target="_blank" rel="noopener">transformer 位置编码</a></p></li><li><p><a href="https://www.zhihu.com/search?type=content&amp;q=transformer多头的好处" target="_blank" rel="noopener">transformer 多头的好处</a></p></li><li><p><a href="https://www.zhihu.com/question/395811291" target="_blank" rel="noopener">transformer 为什么使用 layer normalization，而不是其他的归一化方法</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/266069794" target="_blank" rel="noopener">计算机视觉”新”范式: Transforme</a></p></li><li><p>Transformer课程——李宏毅</p></li><li><p><a href="https://www.zhihu.com/question/347678607/answer/864217252" target="_blank" rel="noopener">如何理解<em>Transformer</em>论文中的positional encoding，和三角函数有什么关系？</a></p></li><li><p><a href="https://blog.csdn.net/liuxiao214/article/details/81037416" target="_blank" rel="noopener">BatchNormalization、LayerNormalization、InstanceNorm、GroupNorm、SwitchableNorm总结</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;论文阅读-Transformer-Attention-Is-All-You-Need&quot;&gt;&lt;a href=&quot;#论文阅读-Transformer-Attention-Is-All-You-Need&quot; class=&quot;headerlink&quot; title=&quot;[论文阅读] T
      
    
    </summary>
    
    
      <category term="Paper" scheme="http://yoursite.com/categories/Paper/"/>
    
    
      <category term="Paper" scheme="http://yoursite.com/tags/Paper/"/>
    
      <category term="Transformer" scheme="http://yoursite.com/tags/Transformer/"/>
    
  </entry>
  
  <entry>
    <title>Scala练手 2048</title>
    <link href="http://yoursite.com/2021/05/12/[Scala]%202048%E5%B0%8F%E6%B8%B8%E6%88%8F/"/>
    <id>http://yoursite.com/2021/05/12/[Scala]%202048%E5%B0%8F%E6%B8%B8%E6%88%8F/</id>
    <published>2021-05-12T10:54:38.000Z</published>
    <updated>2021-05-12T10:55:57.154Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Scala-2048小游戏"><a href="#Scala-2048小游戏" class="headerlink" title="[Scala] 2048小游戏"></a>[Scala] 2048小游戏</h1><blockquote><p>很长一段时间没有用过Scala，重新学习了下顺便写个小游戏练练手</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20210512183822186.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyODE1ODA3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>规则</strong></p><ul><li>相同数字的两个格子，相撞时数字会相加。</li><li>每次滑动时，空白处会随机刷新出一个数字的格子。</li><li>当界面全部被数字填满时游戏结束；当界面中最大数字是2048时，游戏胜利</li></ul><p><strong>代码</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Game2048</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> target = <span class="number">2048</span></span><br><span class="line">  <span class="keyword">var</span> highest = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="type">SwingUtilities</span>.invokeLater(() =&gt; &#123;</span><br><span class="line">      <span class="keyword">val</span> f = <span class="keyword">new</span> <span class="type">JFrame</span></span><br><span class="line">      f.setDefaultCloseOperation(<span class="number">3</span>)</span><br><span class="line">      f.setTitle(<span class="string">"2048"</span>)</span><br><span class="line">      f.add(<span class="keyword">new</span> <span class="type">Game</span>, <span class="type">BorderLayout</span>.<span class="type">CENTER</span>)</span><br><span class="line">      f.pack()</span><br><span class="line">      f.setLocationRelativeTo(<span class="literal">null</span>)</span><br><span class="line">      f.setVisible(<span class="literal">true</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Game</span> <span class="keyword">extends</span> <span class="title">JPanel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> (rand, side) = (<span class="keyword">new</span> <span class="type">Random</span>, <span class="number">4</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> (tiles, game) = (<span class="type">Array</span>.ofDim[<span class="type">Tile</span>](side, side), <span class="type">State</span>.start)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">private</span> <span class="keyword">val</span> colorTable =</span><br><span class="line">      <span class="type">Seq</span>(<span class="keyword">new</span> <span class="type">Color</span>(<span class="number">0x701710</span>), <span class="keyword">new</span> <span class="type">Color</span>(<span class="number">0xFFE4C3</span>), <span class="keyword">new</span> <span class="type">Color</span>(<span class="number">0xfff4d3</span>), <span class="keyword">new</span> <span class="type">Color</span>(<span class="number">0xffdac3</span>), <span class="keyword">new</span> <span class="type">Color</span>(<span class="number">0xe7b08e</span>), <span class="keyword">new</span> <span class="type">Color</span>(<span class="number">0xe7bf8e</span>),</span><br><span class="line">        <span class="keyword">new</span> <span class="type">Color</span>(<span class="number">0xffc4c3</span>), <span class="keyword">new</span> <span class="type">Color</span>(<span class="number">0xE7948e</span>), <span class="keyword">new</span> <span class="type">Color</span>(<span class="number">0xbe7e56</span>), <span class="keyword">new</span> <span class="type">Color</span>(<span class="number">0xbe5e56</span>), <span class="keyword">new</span> <span class="type">Color</span>(<span class="number">0x9c3931</span>), <span class="keyword">new</span> <span class="type">Color</span>(<span class="number">0x701710</span>))</span><br><span class="line"></span><br><span class="line">    setPreferredSize(<span class="keyword">new</span> <span class="type">Dimension</span>(<span class="number">900</span>, <span class="number">700</span>))</span><br><span class="line">    setBackground(<span class="keyword">new</span> <span class="type">Color</span>(<span class="number">0xFAF8EF</span>))</span><br><span class="line">    setFont(<span class="keyword">new</span> <span class="type">Font</span>(<span class="string">"SansSerif"</span>, <span class="type">Font</span>.<span class="type">BOLD</span>, <span class="number">48</span>))</span><br><span class="line">    setFocusable(<span class="literal">true</span>)</span><br><span class="line">    addMouseListener(<span class="keyword">new</span> <span class="type">MouseAdapter</span>() &#123;</span><br><span class="line">      <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">mousePressed</span></span>(e: <span class="type">MouseEvent</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">        startGame()</span><br><span class="line">        repaint()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    addKeyListener(<span class="keyword">new</span> <span class="type">KeyAdapter</span>() &#123;</span><br><span class="line">      <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">keyPressed</span></span>(e: <span class="type">KeyEvent</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">        e.getKeyCode <span class="keyword">match</span> &#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="type">KeyEvent</span>.<span class="type">VK_UP</span> =&gt; moveUp()</span><br><span class="line">          <span class="keyword">case</span> <span class="type">KeyEvent</span>.<span class="type">VK_DOWN</span> =&gt; moveDown()</span><br><span class="line">          <span class="keyword">case</span> <span class="type">KeyEvent</span>.<span class="type">VK_LEFT</span> =&gt; moveLeft()</span><br><span class="line">          <span class="keyword">case</span> <span class="type">KeyEvent</span>.<span class="type">VK_RIGHT</span> =&gt; moveRight()</span><br><span class="line">          <span class="keyword">case</span> _ =&gt;</span><br><span class="line">        &#125;</span><br><span class="line">        repaint()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">paintComponent</span></span>(gg: <span class="type">Graphics</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">      <span class="keyword">super</span>.paintComponent(gg)</span><br><span class="line">      <span class="keyword">val</span> g = gg.asInstanceOf[<span class="type">Graphics2D</span>]</span><br><span class="line">      g.setRenderingHint(<span class="type">RenderingHints</span>.<span class="type">KEY_ANTIALIASING</span>, <span class="type">RenderingHints</span>.<span class="type">VALUE_ANTIALIAS_ON</span>)</span><br><span class="line">      drawGrid(g)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">drawGrid</span></span>(g: <span class="type">Graphics2D</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">      <span class="keyword">val</span> (gridColor, emptyColor, startColor) = (<span class="keyword">new</span> <span class="type">Color</span>(<span class="number">0xBBADA0</span>), <span class="keyword">new</span> <span class="type">Color</span>(<span class="number">0xCDC1B4</span>), <span class="keyword">new</span> <span class="type">Color</span>(<span class="number">0xFFEBCD</span>))</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (game == <span class="type">State</span>.running) &#123;</span><br><span class="line">        g.setColor(gridColor)</span><br><span class="line">        g.fillRoundRect(<span class="number">200</span>, <span class="number">100</span>, <span class="number">499</span>, <span class="number">499</span>, <span class="number">15</span>, <span class="number">15</span>)</span><br><span class="line">        <span class="keyword">for</span> (</span><br><span class="line">          r &lt;- <span class="number">0</span> until side;</span><br><span class="line">          c &lt;- <span class="number">0</span> until side</span><br><span class="line">        ) <span class="keyword">if</span> (<span class="type">Option</span>(tiles(r)(c)).isEmpty) &#123;</span><br><span class="line">          g.setColor(emptyColor)</span><br><span class="line">          g.fillRoundRect(<span class="number">215</span> + c * <span class="number">121</span>, <span class="number">115</span> + r * <span class="number">121</span>, <span class="number">106</span>, <span class="number">106</span>, <span class="number">7</span>, <span class="number">7</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> drawTile(g, r, c)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        g.setColor(startColor)</span><br><span class="line">        g.fillRoundRect(<span class="number">215</span>, <span class="number">115</span>, <span class="number">469</span>, <span class="number">469</span>, <span class="number">7</span>, <span class="number">7</span>)</span><br><span class="line">        g.setColor(gridColor.darker)</span><br><span class="line">        g.setFont(<span class="keyword">new</span> <span class="type">Font</span>(<span class="string">"SansSerif"</span>, <span class="type">Font</span>.<span class="type">BOLD</span>, <span class="number">128</span>))</span><br><span class="line">        g.drawString(<span class="string">"2048"</span>, <span class="number">310</span>, <span class="number">270</span>)</span><br><span class="line">        g.setFont(<span class="keyword">new</span> <span class="type">Font</span>(<span class="string">"SansSerif"</span>, <span class="type">Font</span>.<span class="type">BOLD</span>, <span class="number">20</span>))</span><br><span class="line">        <span class="keyword">if</span> (game == <span class="type">State</span>.won) g.drawString(<span class="string">"you made it!"</span>, <span class="number">390</span>, <span class="number">350</span>)</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (game == <span class="type">State</span>.over) g.drawString(<span class="string">"game over"</span>, <span class="number">400</span>, <span class="number">350</span>)</span><br><span class="line">        g.setColor(gridColor)</span><br><span class="line">        g.drawString(<span class="string">"click to start a new game"</span>, <span class="number">330</span>, <span class="number">470</span>)</span><br><span class="line">        g.drawString(<span class="string">"(use arrow keys to move tiles)"</span>, <span class="number">310</span>, <span class="number">530</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">drawTile</span></span>(g: <span class="type">Graphics2D</span>, r: <span class="type">Int</span>, c: <span class="type">Int</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">      <span class="keyword">val</span> value = tiles(r)(c).value</span><br><span class="line">      g.setColor(colorTable((math.log(value) / math.log(<span class="number">2</span>)).toInt + <span class="number">1</span>))</span><br><span class="line">      g.fillRoundRect(<span class="number">215</span> + c * <span class="number">121</span>, <span class="number">115</span> + r * <span class="number">121</span>, <span class="number">106</span>, <span class="number">106</span>, <span class="number">7</span>, <span class="number">7</span>)</span><br><span class="line">      g.setColor(<span class="keyword">if</span> (value &lt; <span class="number">128</span>) colorTable.head <span class="keyword">else</span> colorTable(<span class="number">1</span>))</span><br><span class="line">      <span class="keyword">val</span> (s, fm) = (value.toString, g.getFontMetrics)</span><br><span class="line">      <span class="keyword">val</span> asc = fm.getAscent</span><br><span class="line">      <span class="keyword">val</span> (x, y) = (<span class="number">215</span> + c * <span class="number">121</span> + (<span class="number">106</span> - fm.stringWidth(s)) / <span class="number">2</span>, <span class="number">115</span> + r * <span class="number">121</span> + (asc + (<span class="number">106</span> - (asc + fm.getDescent)) / <span class="number">2</span>))</span><br><span class="line">      g.drawString(s, x, y)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">moveUp</span></span>(checkingAvailableMoves: <span class="type">Boolean</span> = <span class="literal">false</span>) = move(<span class="number">-1</span>, <span class="number">0</span>, checkingAvailableMoves)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">moveDown</span></span>(checkingAvailableMoves: <span class="type">Boolean</span> = <span class="literal">false</span>) = move(<span class="number">1</span>, <span class="number">0</span>, checkingAvailableMoves)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">moveLeft</span></span>(checkingAvailableMoves: <span class="type">Boolean</span> = <span class="literal">false</span>) = move(<span class="number">0</span>, <span class="number">-1</span>, checkingAvailableMoves)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">moveRight</span></span>(checkingAvailableMoves: <span class="type">Boolean</span> = <span class="literal">false</span>) = move(<span class="number">0</span>, <span class="number">1</span>, checkingAvailableMoves)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">clearMerged</span></span>(): <span class="type">Unit</span> = <span class="keyword">for</span> (row &lt;- tiles; tile &lt;- row) <span class="keyword">if</span> (<span class="type">Option</span>(tile).isDefined) tile.setMerged()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">movesAvailable</span></span>() = moveUp(<span class="literal">true</span>) || moveDown(<span class="literal">true</span>) || moveLeft(<span class="literal">true</span>) || moveRight(<span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">move</span></span>(yIncr: <span class="type">Int</span>, xIncr: <span class="type">Int</span>, checkingAvailableMoves: <span class="type">Boolean</span>): <span class="type">Boolean</span> = &#123;</span><br><span class="line">      <span class="keyword">var</span> moved = <span class="literal">false</span></span><br><span class="line">      <span class="keyword">for</span> (i &lt;- <span class="number">0</span> until side;</span><br><span class="line">           j &lt;- <span class="number">0</span> until side) <span class="keyword">if</span> (<span class="type">Option</span>(tiles(i)(j)).isDefined) &#123;</span><br><span class="line">        <span class="keyword">var</span> (r, c) = (i, j)</span><br><span class="line">        <span class="keyword">var</span> (nextR, nextC, breek) = (i + yIncr, j + xIncr, <span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">while</span> ((nextR &gt;= <span class="number">0</span> &amp;&amp; nextR &lt; side &amp;&amp; nextC &gt;= <span class="number">0</span> &amp;&amp; nextC &lt; side) &amp;&amp; !breek) &#123;</span><br><span class="line">          <span class="keyword">val</span> (next, curr) = (tiles(nextR)(nextC), tiles(r)(c))</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (<span class="type">Option</span>(next).isEmpty)</span><br><span class="line">            <span class="keyword">if</span> (checkingAvailableMoves) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">              tiles(nextR)(nextC) = curr</span><br><span class="line">              tiles(r)(c) = <span class="literal">null</span></span><br><span class="line">              r = nextR</span><br><span class="line">              c = nextC</span><br><span class="line">              nextR += yIncr</span><br><span class="line">              nextC += xIncr</span><br><span class="line">              moved = <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (next.canMergeWith(curr)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (checkingAvailableMoves) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            highest = math.max(next.mergeWith(curr), highest)</span><br><span class="line">            tiles(r)(c) = <span class="literal">null</span></span><br><span class="line">            breek = <span class="literal">true</span></span><br><span class="line">            moved = <span class="literal">true</span></span><br><span class="line">          &#125; <span class="keyword">else</span> breek = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      updateState(moved)</span><br><span class="line">      moved</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">updateState</span></span>(moved: <span class="type">Boolean</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">      <span class="keyword">if</span> (moved &amp;&amp; highest &lt; target) &#123;</span><br><span class="line">        clearMerged()</span><br><span class="line">        addRandomTile()</span><br><span class="line">        <span class="keyword">if</span> (!movesAvailable) game = <span class="type">State</span>.over</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (highest == target) game = <span class="type">State</span>.won</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">startGame</span></span>(): <span class="type">Unit</span> = <span class="keyword">if</span> (game ne <span class="type">State</span>.running) &#123;</span><br><span class="line">      highest = <span class="number">0</span></span><br><span class="line">      game = <span class="type">State</span>.running</span><br><span class="line">      tiles = <span class="type">Array</span>.ofDim[<span class="type">Tile</span>](side, side)</span><br><span class="line">      addRandomTile()</span><br><span class="line">      addRandomTile()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">addRandomTile</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">      <span class="keyword">var</span> pos = rand.nextInt(side * side)</span><br><span class="line">      <span class="keyword">var</span> (row, col) = (<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">      do &#123;</span><br><span class="line">        pos = (pos + <span class="number">1</span>) % (side * side)</span><br><span class="line">        row = pos / side</span><br><span class="line">        col = pos % side</span><br><span class="line">      &#125; <span class="keyword">while</span> (<span class="type">Option</span>(tiles(row)(col)).isDefined)</span><br><span class="line">      tiles(row)(col) = <span class="type">Tile</span>(<span class="keyword">if</span> (rand.nextInt(<span class="number">10</span>) == <span class="number">0</span>) <span class="number">4</span> <span class="keyword">else</span> <span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><a href="https://github.com/BENULL/2048" target="_blank" rel="noopener">完整代码</a></strong></p><p><strong>后面可以考虑加上AI，尝试基于规则或强化学习的方法</strong></p><ul><li><a href="http://blog.codinglabs.org/articles/2048-ai-analysis.html" target="_blank" rel="noopener">2048-AI程序算法分析</a></li><li><a href="https://zhuanlan.zhihu.com/p/150248976" target="_blank" rel="noopener">你玩《2048》能拿多少分？AI的最高分纪录：401912</a></li><li><a href="https://blog.csdn.net/qq_32767041/article/details/80634244" target="_blank" rel="noopener">2048AI设计与实现</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Scala-2048小游戏&quot;&gt;&lt;a href=&quot;#Scala-2048小游戏&quot; class=&quot;headerlink&quot; title=&quot;[Scala] 2048小游戏&quot;&gt;&lt;/a&gt;[Scala] 2048小游戏&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;很长一段时间没有用
      
    
    </summary>
    
    
      <category term="Project" scheme="http://yoursite.com/categories/Project/"/>
    
    
      <category term="Scala" scheme="http://yoursite.com/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>关于Python Decorator你应该知道的一切</title>
    <link href="http://yoursite.com/2021/04/22/%E5%85%B3%E4%BA%8EPython%20Decorator%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84%E4%B8%80%E5%88%87/"/>
    <id>http://yoursite.com/2021/04/22/%E5%85%B3%E4%BA%8EPython%20Decorator%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84%E4%B8%80%E5%88%87/</id>
    <published>2021-04-22T12:58:22.000Z</published>
    <updated>2021-04-22T12:59:02.143Z</updated>
    
    <content type="html"><![CDATA[<h2 id="转载并整理格式自关于Python-Decorator你应该知道的一切"><a href="#转载并整理格式自关于Python-Decorator你应该知道的一切" class="headerlink" title="转载并整理格式自关于Python Decorator你应该知道的一切"></a><strong>转载并整理格式自<a href="https://www.jianshu.com/p/1ae551fb17cd/" target="_blank" rel="noopener">关于Python Decorator你应该知道的一切</a></strong></h2><blockquote><p>关键词：Python、装饰器、装饰器的深入讨论、Python decorator</p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近学习Python,在看一个框架源码过程中对装饰器很困惑，Google了一圈，在stack overflow的一个<a href="http://stackoverflow.com/a/1594484/1337846" target="_blank" rel="noopener">问题</a>讨论下面找到了<a href="http://stackoverflow.com/questions/739654/how-can-i-make-a-chain-of-function-decorators-in-python&quot;" target="_blank" rel="noopener">这个</a>总结，这里几乎有关于Python全部的内容。觉得很好，遂翻译过来。翻译基本都是意译，能看英文的还是尽量看上面链接过去的原版吧！</p><h1 id="Pyton装饰器基础"><a href="#Pyton装饰器基础" class="headerlink" title="Pyton装饰器基础"></a>Pyton装饰器基础</h1><h2 id="在Python中，函数也是对象"><a href="#在Python中，函数也是对象" class="headerlink" title="在Python中，函数也是对象"></a>在Python中，函数也是对象</h2><p>为了理解装饰器，你必须首先理解，在Python中函数也是对象。<br>理解这个知识点很重要。让我们使用一个简单的例子来说明一下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shout</span><span class="params">(word=<span class="string">"yes"</span>)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> word.capitalize()+<span class="string">"!"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> shout()</span><br><span class="line"><span class="comment"># 输出为: 'Yes!'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 函数作为一个对象，你可以像其他对象一样，把它赋值给其他的变量</span></span><br><span class="line">scream = shout</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意我们没有使用圆括号：我们不是调用这个函数，我们把"shout"这个函数赋值给变量"scream"   </span></span><br><span class="line"><span class="comment"># 那意味着你之后可以使用"scream"来调用"shout"这个函数</span></span><br><span class="line"><span class="keyword">print</span> scream()</span><br><span class="line"><span class="comment"># 输出为: 'Yes!'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不仅如此，那意味着你可以移除'shout'这个老的名称，但这个函数仍然可以通过'scream'访问</span></span><br><span class="line"><span class="keyword">del</span> shout</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">print</span> shout()</span><br><span class="line"><span class="keyword">except</span> NameError, e:</span><br><span class="line">    <span class="keyword">print</span> e</span><br><span class="line">    <span class="comment"># 输出为: "name 'shout' is not defined"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> scream()</span><br><span class="line"><span class="comment"># 输出为: 'Yes!'</span></span><br></pre></td></tr></table></figure><p>好了，在心里记住这个知识点。我们之后很快要用到它。<br>Python中函数还有另一个有趣的特性，那就是它可以在其他函数里面定义！<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">talk</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 你可以在"talk"函数中定义一个函数...</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">whisper</span><span class="params">(word=<span class="string">"yes"</span>)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> word.lower()+<span class="string">"..."</span></span><br><span class="line"></span><br><span class="line">     <span class="comment"># ...并且你可以马上使用这个函数</span></span><br><span class="line">    <span class="keyword">print</span> whisper()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 你每次调用"talk"这个函数的时候，它会定义一个"whisper"函数，之后这个"whisper"将在"talk"里面被调用</span></span><br><span class="line">talk()</span><br><span class="line"><span class="comment"># 输出为:"yes..."</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 但是在"talk"这个函数的作用域之外，"whisper"这个函数是不存在的</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">print</span> whisper()</span><br><span class="line"><span class="keyword">except</span> NameError, e:</span><br><span class="line">    <span class="keyword">print</span> e</span><br><span class="line">    <span class="comment"># 输出为: "name 'whisper' is not defined"*</span></span><br></pre></td></tr></table></figure></p><h2 id="函数的引用"><a href="#函数的引用" class="headerlink" title="函数的引用"></a>函数的引用</h2><p>Okay，就这些东西吗？有趣的部分该上场了…<br>你已经看见，函数是对象。因此，函数:</p><ul><li>可以赋值给其他变量</li><li>可以在其它函数里面定义</li></ul><p>那意味着<strong>一个函数可以被另一个函数<code>return</code></strong>。我们来看个例子! ☺<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getTalk</span><span class="params">(kind=<span class="string">"shout"</span>)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 我们定义了一些函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shout</span><span class="params">(word=<span class="string">"yes"</span>)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> word.capitalize()+<span class="string">"!"</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">whisper</span><span class="params">(word=<span class="string">"yes"</span>)</span> :</span></span><br><span class="line">        <span class="keyword">return</span> word.lower()+<span class="string">"..."</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 然后我们返回他们中的一个</span></span><br><span class="line">    <span class="keyword">if</span> kind == <span class="string">"shout"</span>:</span><br><span class="line">        <span class="comment"># 我们没有用"()", 我们不是要调用这个函数</span></span><br><span class="line">        <span class="comment"># 我们返回了这个函数对象</span></span><br><span class="line">        <span class="keyword">return</span> shout  </span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> whisper</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们怎么使用它呢?</span></span><br><span class="line"><span class="comment"># 获取函数，并将它赋值给一个变量</span></span><br><span class="line">talk = getTalk()      </span><br><span class="line"></span><br><span class="line"><span class="comment"># 你可以看到在这里"talk"是一个函数对象:</span></span><br><span class="line"><span class="keyword">print</span> talk</span><br><span class="line"><span class="comment"># 输出为: &lt;function shout at 0xb7ea817c&gt;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个就是被函数返回的对象</span></span><br><span class="line"><span class="keyword">print</span> talk()</span><br><span class="line"><span class="comment"># 输出为: Yes!</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 你甚至可以直接使用它:</span></span><br><span class="line"><span class="keyword">print</span> getTalk(<span class="string">"whisper"</span>)()</span><br><span class="line"><span class="comment"># 输出为: yes...</span></span><br></pre></td></tr></table></figure></p><p>等等…这里有我们没有注意到的地方!<br>既然你可以<code>return</code>一个函数，你就可以把一个函数当参数传递:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">doSomethingBefore</span><span class="params">(func)</span>:</span> </span><br><span class="line">    <span class="keyword">print</span> <span class="string">"I do something before then I call the function you gave me"</span></span><br><span class="line">    <span class="keyword">print</span> func()</span><br><span class="line"></span><br><span class="line">doSomethingBefore(scream)</span><br><span class="line"><span class="comment"># 输出为: </span></span><br><span class="line"><span class="comment">#I do something before then I call the function you gave me</span></span><br><span class="line"><span class="comment">#Yes!</span></span><br></pre></td></tr></table></figure></p><p>好了，你已经具备了理解装饰器的所有知识点。你知道，装饰器就是 “封装”, 这意味着<strong>它可以让你在被它装饰的函数前面和后面执行一些代码</strong>，而不必改动被装饰的函数本身。</p><h2 id="手动创建装饰器"><a href="#手动创建装饰器" class="headerlink" title="手动创建装饰器"></a>手动创建装饰器</h2><p>你如何手动构建一个装饰器:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 装饰是一个函数，该函数需要另一个函数作为它的参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_shiny_new_decorator</span><span class="params">(a_function_to_decorate)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 在装饰器的函数实现里面它定义了另一个函数: 他就是封装函数(wrapper)</span></span><br><span class="line">    <span class="comment"># 这个函数将原来的函数封装到里面</span></span><br><span class="line">    <span class="comment"># 因此你可以在原来函数的前面和后面执行一些附加代码</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">the_wrapper_around_the_original_function</span><span class="params">()</span>:</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment"># 在这里放置你想在原来函数执行前执行的代码</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Before the function runs"</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment"># 调用原来的函数(使用圆括号)</span></span><br><span class="line">        a_function_to_decorate()</span><br><span class="line">    </span><br><span class="line">        <span class="comment"># 在这里放置你想在原来函数执行后执行的代码</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"After the function runs"</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 这个时候，"a_function_to_decorate"并没有执行</span></span><br><span class="line">    <span class="comment"># 我们返回刚才创建的封装函数</span></span><br><span class="line">    <span class="comment"># 这个封装函数包含了原来的函数，和将在原来函数前面和后面执行的代码。我们就可以使用它了!</span></span><br><span class="line">    <span class="keyword">return</span> the_wrapper_around_the_original_function</span><br><span class="line"></span><br><span class="line"><span class="comment"># 想象你创建了一个你再也不想修改的函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a_stand_alone_function</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"I am a stand alone function, don't you dare modify me"</span></span><br><span class="line"></span><br><span class="line">a_stand_alone_function() </span><br><span class="line"><span class="comment"># 输出为: I am a stand alone function, don't you dare modify me</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 现在你可以装饰这个函数来扩展它的行为</span></span><br><span class="line"><span class="comment"># 只需要将这个函数传入装饰器，那它将被动态的包在任何你想执行的代码间，并且返回一个可被使用的新函数:</span></span><br><span class="line">a_stand_alone_function_decorated = my_shiny_new_decorator(a_stand_alone_function)</span><br><span class="line">a_stand_alone_function_decorated()</span><br><span class="line"><span class="comment">#输出为:</span></span><br><span class="line"><span class="comment">#Before the function runs</span></span><br><span class="line"><span class="comment">#I am a stand alone function, don't you dare modify me</span></span><br><span class="line"><span class="comment">#After the function runs</span></span><br></pre></td></tr></table></figure></p><p>现在，你可能想在每次调用 <code>a_stand_alone_function</code>的时候，真正被执行的函数是 <code>a_stand_alone_function_decorated</code>。那很容易，只需要使用 <code>my_shiny_new_decorator</code>返回的函数赋值给原来的 <code>a_stand_alone_function</code>这个函数名(其实是个变量):<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a_stand_alone_function = my_shiny_new_decorator(a_stand_alone_function)</span><br><span class="line">a_stand_alone_function()</span><br><span class="line"><span class="comment">#输出为:</span></span><br><span class="line"><span class="comment">#Before the function runs</span></span><br><span class="line"><span class="comment">#I am a stand alone function, don't you dare modify me</span></span><br><span class="line"><span class="comment">#After the function runs</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 你猜怎么着？这就是装饰器做的事情。</span></span><br></pre></td></tr></table></figure></p><h2 id="装饰器揭秘"><a href="#装饰器揭秘" class="headerlink" title="装饰器揭秘"></a>装饰器揭秘</h2><p>前面的例子，使用Python的装饰器语法糖来重写就是下面的样子:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@my_shiny_new_decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">another_stand_alone_function</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Leave me alone"</span></span><br><span class="line"></span><br><span class="line">another_stand_alone_function()  </span><br><span class="line"><span class="comment"># 输出为:  </span></span><br><span class="line"><span class="comment">#Before the function runs</span></span><br><span class="line"><span class="comment">#Leave me alone</span></span><br><span class="line"><span class="comment">#After the function runs</span></span><br></pre></td></tr></table></figure></p><p>是的，这就是全部，就是这么简单。<code>@decorator</code> 只是下面表达式的简写:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">another_stand_alone_function = my_shiny_new_decorator(another_stand_alone_function)</span><br></pre></td></tr></table></figure></p><p>这里的装饰器只是<a href="https://link.jianshu.com?t=http://en.wikipedia.org/wiki/Decorator_pattern" target="_blank" rel="noopener">装饰器设计模式</a> 的一种Python化变体。Python嵌入了多种经典的设计模式来简化开发(比如迭代器(iterators))。<br>当然，你可以堆积装饰器(使用多层装饰器)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bread</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"&lt;/''''''\&gt;;"</span></span><br><span class="line">        func()</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"&lt;\______/&gt;;"</span></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ingredients</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"#tomatoes#"</span></span><br><span class="line">        func()</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"~salad~"</span></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sandwich</span><span class="params">(food=<span class="string">"--ham--"</span>)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> food</span><br><span class="line"></span><br><span class="line">sandwich()</span><br><span class="line"><span class="comment"># 输出为: --ham--</span></span><br><span class="line">sandwich = bread(ingredients(sandwich))</span><br><span class="line">sandwich()</span><br><span class="line"><span class="comment">#outputs:</span></span><br><span class="line"><span class="comment">#&lt;/''''''\&gt;;</span></span><br><span class="line"><span class="comment"># #tomatoes#</span></span><br><span class="line"><span class="comment"># --ham--</span></span><br><span class="line"><span class="comment"># ~salad~</span></span><br><span class="line"><span class="comment">#&lt;\______/&gt;;</span></span><br></pre></td></tr></table></figure><p>使用Python的装饰器语法糖:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@bread</span></span><br><span class="line"><span class="meta">@ingredients</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sandwich</span><span class="params">(food=<span class="string">"--ham--"</span>)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> food</span><br><span class="line"></span><br><span class="line">sandwich()</span><br><span class="line"><span class="comment">#outputs:</span></span><br><span class="line"><span class="comment">#&lt;/''''''\&gt;;</span></span><br><span class="line"><span class="comment"># #tomatoes#</span></span><br><span class="line"><span class="comment"># --ham--</span></span><br><span class="line"><span class="comment"># ~salad~</span></span><br><span class="line"><span class="comment">#&lt;\______/&gt;;</span></span><br></pre></td></tr></table></figure></p><p>你放置装饰器的顺序很重要:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ingredients</span></span><br><span class="line"><span class="meta">@bread</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">strange_sandwich</span><span class="params">(food=<span class="string">"--ham--"</span>)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> food</span><br><span class="line"></span><br><span class="line">strange_sandwich()</span><br><span class="line"><span class="comment">#outputs:</span></span><br><span class="line"><span class="comment">##tomatoes#</span></span><br><span class="line"><span class="comment">#&lt;/''''''\&gt;;</span></span><br><span class="line"><span class="comment"># --ham--</span></span><br><span class="line"><span class="comment">#&lt;\______/&gt;;</span></span><br><span class="line"><span class="comment"># ~salad~</span></span><br></pre></td></tr></table></figure></p><h1 id="现在-回答问题-请参考stack-overflorw-上的相关问题"><a href="#现在-回答问题-请参考stack-overflorw-上的相关问题" class="headerlink" title="现在: 回答问题(请参考stack overflorw 上的相关问题)"></a>现在: 回答问题(请参考<a href="https://link.jianshu.com?t=http://stackoverflow.com/questions/739654/how-can-i-make-a-chain-of-function-decorators-in-python" target="_blank" rel="noopener">stack overflorw</a> 上的相关问题)</h1><p>作为结论，你可以很容易看出如何回答问题：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使其变bold的装饰器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">makebold</span><span class="params">(fn)</span>:</span></span><br><span class="line">    <span class="comment"># 装饰器将要返回的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="comment"># 在原函数前面和后面插入一些代码</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&lt;b&gt;;"</span> + fn() + <span class="string">"&lt;/b&gt;;"</span></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使其变italic的装饰器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">makeitalic</span><span class="params">(fn)</span>:</span></span><br><span class="line">      <span class="comment"># 装饰器将要返回的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="comment"># 在原函数前面和后面插入一些代码</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&lt;i&gt;;"</span> + fn() + <span class="string">"&lt;/i&gt;;"</span></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@makebold</span></span><br><span class="line"><span class="meta">@makeitalic</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> say() </span><br><span class="line"><span class="comment"># 输出为: &lt;b&gt;;&lt;i&gt;;hello&lt;/i&gt;;&lt;/b&gt;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这和下面代码效果相同</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello"</span></span><br><span class="line">say = makebold(makeitalic(say))</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> say() </span><br><span class="line"><span class="comment"># 输出为: &lt;b&gt;;&lt;i&gt;;hello&lt;/i&gt;;&lt;/b&gt;;</span></span><br></pre></td></tr></table></figure></p><p>你可以高兴的离开这里了，或者再费点脑子来看看装饰器的高级用法。</p><h1 id="更深入的讨论装饰器"><a href="#更深入的讨论装饰器" class="headerlink" title="更深入的讨论装饰器"></a>更深入的讨论装饰器</h1><h2 id="向被装饰的函数传参数"><a href="#向被装饰的函数传参数" class="headerlink" title="向被装饰的函数传参数"></a>向被装饰的函数传参数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这不是黑魔法，你只需要让封装函数传递这些参数:</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a_decorator_passing_arguments</span><span class="params">(function_to_decorate)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">a_wrapper_accepting_arguments</span><span class="params">(arg1, arg2)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"I got args! Look:"</span>, arg1, arg2</span><br><span class="line">        function_to_decorate(arg1, arg2)</span><br><span class="line">    <span class="keyword">return</span> a_wrapper_accepting_arguments</span><br><span class="line"></span><br><span class="line"><span class="comment"># 因为当你调用被装饰器返回的函数时，实际你是在调用封装函数  </span></span><br><span class="line"><span class="comment"># 所以向封装函数传递参数可以让封装函数把参数传递给被装饰的函数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@a_decorator_passing_arguments</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_full_name</span><span class="params">(first_name, last_name)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"My name is"</span>, first_name, last_name</span><br><span class="line">    </span><br><span class="line">print_full_name(<span class="string">"Peter"</span>, <span class="string">"Venkman"</span>)</span><br><span class="line"><span class="comment"># 输出为:</span></span><br><span class="line"><span class="comment"># I got args! Look: Peter Venkman</span></span><br><span class="line"><span class="comment"># My name is Peter Venkman</span></span><br></pre></td></tr></table></figure><h2 id="装饰方法"><a href="#装饰方法" class="headerlink" title="装饰方法"></a>装饰方法</h2><p>Python中方法和函数几乎是一样的，这个特性很nice。唯一的不同是方法期望它的第一个参数是对当前对象的引用(<code>self</code>)。<br>那意味着你可以使用相同的方式来给方法添加装饰器！只是需要将<code>self</code>考虑在内:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">method_friendly_decorator</span><span class="params">(method_to_decorate)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(self, lie)</span>:</span></span><br><span class="line">        lie = lie - <span class="number">3</span> <span class="comment"># 很友好吧，再次减少了年龄 :-)</span></span><br><span class="line">        <span class="keyword">return</span> method_to_decorate(self, lie)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lucy</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">self.age = <span class="number">32</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @method_friendly_decorator</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sayYourAge</span><span class="params">(self, lie)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"I am %s, what did you think?"</span> % (self.age + lie)</span><br><span class="line"></span><br><span class="line">l = Lucy()</span><br><span class="line">l.sayYourAge(<span class="number">-3</span>)</span><br><span class="line"><span class="comment"># 输出为: I am 26, what did you think?</span></span><br></pre></td></tr></table></figure></p><p>如果你在写一个通用的装饰器—可以接收任何参数的函数或者方法—这时候只需要使用 <code>*args, **kwargs</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a_decorator_passing_arbitrary_arguments</span><span class="params">(function_to_decorate)</span>:</span></span><br><span class="line">    <span class="comment"># 封装函数可以接收任何的参数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">a_wrapper_accepting_arbitrary_arguments</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Do I have args?:"</span></span><br><span class="line">        <span class="keyword">print</span> args</span><br><span class="line">        <span class="keyword">print</span> kwargs</span><br><span class="line">        <span class="comment"># 然后你解包出参数，这里是 *args, **kwargs </span></span><br><span class="line">        <span class="comment"># 如果你不熟悉怎么解包，可以查看：</span></span><br><span class="line">        <span class="comment"># http://www.saltycrane.com/blog/2008/01/how-to-use-args-and-kwargs-in-python/</span></span><br><span class="line">        function_to_decorate(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> a_wrapper_accepting_arbitrary_arguments</span><br><span class="line"></span><br><span class="line"><span class="meta">@a_decorator_passing_arbitrary_arguments</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">function_with_no_argument</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Python is cool, no argument here."</span></span><br><span class="line"></span><br><span class="line">function_with_no_argument()</span><br><span class="line"><span class="comment">#输出为:</span></span><br><span class="line"><span class="comment">#Do I have args?:</span></span><br><span class="line"><span class="comment">#()</span></span><br><span class="line"><span class="comment">#&#123;&#125;</span></span><br><span class="line"><span class="comment">#Python is cool, no argument here.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@a_decorator_passing_arbitrary_arguments</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">function_with_arguments</span><span class="params">(a, b, c)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> a, b, c</span><br><span class="line">    </span><br><span class="line">function_with_arguments(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="comment"># 输出为:</span></span><br><span class="line"><span class="comment">#Do I have args?:</span></span><br><span class="line"><span class="comment">#(1, 2, 3)</span></span><br><span class="line"><span class="comment">#&#123;&#125;</span></span><br><span class="line"><span class="comment">#1 2 3 </span></span><br><span class="line"></span><br><span class="line"><span class="meta">@a_decorator_passing_arbitrary_arguments</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">function_with_named_arguments</span><span class="params">(a, b, c, platypus=<span class="string">"Why not ?"</span>)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Do %s, %s and %s like platypus? %s"</span> %\</span><br><span class="line">    (a, b, c, platypus)</span><br><span class="line"></span><br><span class="line">function_with_named_arguments(<span class="string">"Bill"</span>, <span class="string">"Linus"</span>, <span class="string">"Steve"</span>, platypus=<span class="string">"Indeed!"</span>)</span><br><span class="line"><span class="comment"># 输出为:</span></span><br><span class="line"><span class="comment">#Do I have args ? :</span></span><br><span class="line"><span class="comment">#('Bill', 'Linus', 'Steve')</span></span><br><span class="line"><span class="comment">#&#123;'platypus': 'Indeed!'&#125;</span></span><br><span class="line"><span class="comment">#Do Bill, Linus and Steve like platypus? Indeed!</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mary</span><span class="params">(object)</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.age = <span class="number">31</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">    @a_decorator_passing_arbitrary_arguments</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sayYourAge</span><span class="params">(self, lie=<span class="number">-3</span>)</span>:</span> <span class="comment"># 这时候你可以添加一个默认参数值</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"I am %s, what did you think ?"</span> % (self.age + lie)</span><br><span class="line"></span><br><span class="line">m = Mary()</span><br><span class="line">m.sayYourAge()</span><br><span class="line"><span class="comment"># 输出为:</span></span><br><span class="line"><span class="comment"># Do I have args?:</span></span><br><span class="line"><span class="comment">#(&lt;__main__.Mary object at 0xb7d303ac&gt;;,)</span></span><br><span class="line"><span class="comment">#&#123;&#125;</span></span><br><span class="line"><span class="comment">#I am 28, what did you think?</span></span><br></pre></td></tr></table></figure><h2 id="给装饰器传递参数"><a href="#给装饰器传递参数" class="headerlink" title="给装饰器传递参数"></a>给装饰器传递参数</h2><p>好了，现在你觉得给装饰器本身传递参数该怎么做呢?<br>这个可能有点绕，因为装饰器必须接收一个函数作为参数。<br>因此，你不能把被装饰函数的参数直接传递给装饰器。<br>在我们说出解决办法前，写点代码来找找灵感:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 装饰器只是普通的函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_decorator</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"I am an ordinary function"</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"I am function returned by the decorator"</span></span><br><span class="line">        func()</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="comment"># 因此，你可以不使用任何的 "@" 就可以调用它</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lazy_function</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"zzzzzzzz"</span></span><br><span class="line"></span><br><span class="line">decorated_function = my_decorator(lazy_function)</span><br><span class="line"><span class="comment"># 输出为: I am an ordinary function</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 它输出 "I am an ordinary function"，因为那就是你在代码里面做的事情:  </span></span><br><span class="line"><span class="comment"># 调用一个函数，没有任何的魔法。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@my_decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lazy_function</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"zzzzzzzz"</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 输出为: I am an ordinary function</span></span><br></pre></td></tr></table></figure></p><p>上面两种方式几乎一样。<code>my_decorator</code>被调用。因此当你在代码里面添加 <code>@my_decorato</code>时，你就在告诉Python去调用被<code>my_decorator</code>变量标示的函数。<br>这很重要! 你给出的这个变量名可以直接指向装饰器<strong>也可以不直接指向</strong>。<br>我们来干点邪恶的事情。 ☺<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator_maker</span><span class="params">()</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">print</span> <span class="string">"I make decorators! I am executed only once: "</span>+\</span><br><span class="line">          <span class="string">"when you make me create a decorator."</span></span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">my_decorator</span><span class="params">(func)</span>:</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">print</span> <span class="string">"I am a decorator! I am executed only when you decorate a function."</span></span><br><span class="line">               </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapped</span><span class="params">()</span>:</span></span><br><span class="line">            <span class="keyword">print</span> (<span class="string">"I am the wrapper around the decorated function. "</span></span><br><span class="line">                  <span class="string">"I am called when you call the decorated function. "</span></span><br><span class="line">                  <span class="string">"As the wrapper, I return the RESULT of the decorated function."</span>)</span><br><span class="line">            <span class="keyword">return</span> func()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">print</span> <span class="string">"As the decorator, I return the wrapped function."</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> wrapped</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">print</span> <span class="string">"As a decorator maker, I return a decorator"</span></span><br><span class="line">    <span class="keyword">return</span> my_decorator</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们创建了一个装饰器。它就只是一个新的函数。</span></span><br><span class="line">new_decorator = decorator_maker()       </span><br><span class="line"><span class="comment"># 输出为:  </span></span><br><span class="line"><span class="comment">#I make decorators! I am executed only once: when you make me create a decorator.</span></span><br><span class="line"><span class="comment">#As a decorator maker, I return a decorator</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后我们装饰一个函数       </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorated_function</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"I am the decorated function."</span></span><br><span class="line"></span><br><span class="line">decorated_function = new_decorator(decorated_function)</span><br><span class="line"><span class="comment"># 输出为:</span></span><br><span class="line"><span class="comment">#I am a decorator! I am executed only when you decorate a function.</span></span><br><span class="line"><span class="comment">#As the decorator, I return the wrapped function</span></span><br><span class="line">     </span><br><span class="line"><span class="comment"># 我们调用这个函数:</span></span><br><span class="line">decorated_function()</span><br><span class="line"><span class="comment"># 输出为:</span></span><br><span class="line"><span class="comment">#I am the wrapper around the decorated function. I am called when you call the decorated function.</span></span><br><span class="line"><span class="comment">#As the wrapper, I return the RESULT of the decorated function.</span></span><br><span class="line"><span class="comment">#I am the decorated function.</span></span><br><span class="line"></span><br><span class="line">这里没有任何惊奇的地方。</span><br><span class="line">让我们再次来做相同的事情，但是省略掉所有讨厌的中间变量：</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorated_function</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"I am the decorated function."</span></span><br><span class="line">decorated_function = decorator_maker()(decorated_function)</span><br><span class="line"><span class="comment"># 输出为:</span></span><br><span class="line"><span class="comment">#I make decorators! I am executed only once: when you make me create a decorator.</span></span><br><span class="line"><span class="comment">#As a decorator maker, I return a decorator</span></span><br><span class="line"><span class="comment">#I am a decorator! I am executed only when you decorate a function.</span></span><br><span class="line"><span class="comment">#As the decorator, I return the wrapped function.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 最后:</span></span><br><span class="line">decorated_function()    </span><br><span class="line"><span class="comment"># 输出为:</span></span><br><span class="line"><span class="comment">#I am the wrapper around the decorated function. I am called when you call the decorated function.</span></span><br><span class="line"><span class="comment">#As the wrapper, I return the RESULT of the decorated function.</span></span><br><span class="line"><span class="comment">#I am the decorated function.</span></span><br></pre></td></tr></table></figure></p><p>让我们使它<strong>更简洁</strong>:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@decorator_maker()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorated_function</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"I am the decorated function."</span></span><br><span class="line"><span class="comment"># 输出为:</span></span><br><span class="line"><span class="comment">#I make decorators! I am executed only once: when you make me create a decorator.</span></span><br><span class="line"><span class="comment">#As a decorator maker, I return a decorator</span></span><br><span class="line"><span class="comment">#I am a decorator! I am executed only when you decorate a function.</span></span><br><span class="line"><span class="comment">#As the decorator, I return the wrapped function.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 最终: </span></span><br><span class="line">decorated_function()    </span><br><span class="line"><span class="comment"># 输出为:</span></span><br><span class="line"><span class="comment">#I am the wrapper around the decorated function. I am called when you call the decorated function.</span></span><br><span class="line"><span class="comment">#As the wrapper, I return the RESULT of the decorated function.</span></span><br><span class="line"><span class="comment">#I am the decorated function.</span></span><br></pre></td></tr></table></figure></p><p>Hey，你注意到了吗？我们除了 <code>@</code>格式的语法糖外还使用了函数调用! :-)<br>因此，回到带参数装饰器的讨论。如果我们可以使用函数来创建装饰器，我们就可以把参数传递给那个函数，对吧？<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator_maker_with_arguments</span><span class="params">(decorator_arg1, decorator_arg2)</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">print</span> <span class="string">"I make decorators! And I accept arguments:"</span>, decorator_arg1, decorator_arg2</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">my_decorator</span><span class="params">(func)</span>:</span></span><br><span class="line">        <span class="comment"># 这里之所有可以传递参数，得益于closures的特性。  </span></span><br><span class="line">        <span class="comment"># 如果你不熟悉closures,你可以假设这是没问题的，</span></span><br><span class="line">        <span class="comment"># 或者读一下: http://stackoverflow.com/questions/13857/can-you-explain-closures-as-they-relate-to-python  </span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">print</span> <span class="string">"I am the decorator. Somehow you passed me arguments:"</span>, decorator_arg1, decorator_arg2</span><br><span class="line">               </span><br><span class="line">        <span class="comment"># 不要把装饰器的参数和函数的参数搞混</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapped</span><span class="params">(function_arg1, function_arg2)</span> :</span></span><br><span class="line">            <span class="keyword">print</span> (<span class="string">"I am the wrapper around the decorated function.\n"</span></span><br><span class="line">                  <span class="string">"I can access all the variables\n"</span></span><br><span class="line">                  <span class="string">"\t- from the decorator: &#123;0&#125; &#123;1&#125;\n"</span></span><br><span class="line">                  <span class="string">"\t- from the function call: &#123;2&#125; &#123;3&#125;\n"</span></span><br><span class="line">                  <span class="string">"Then I can pass them to the decorated function"</span></span><br><span class="line">                  .format(decorator_arg1, decorator_arg2,</span><br><span class="line">                          function_arg1, function_arg2))</span><br><span class="line">            <span class="keyword">return</span> func(function_arg1, function_arg2)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> wrapped</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> my_decorator</span><br><span class="line"></span><br><span class="line"><span class="meta">@decorator_maker_with_arguments("Leonard", "Sheldon")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorated_function_with_arguments</span><span class="params">(function_arg1, function_arg2)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> (<span class="string">"I am the decorated function and only knows about my arguments: &#123;0&#125;"</span></span><br><span class="line">           <span class="string">" &#123;1&#125;"</span>.format(function_arg1, function_arg2))</span><br><span class="line">          </span><br><span class="line">decorated_function_with_arguments(<span class="string">"Rajesh"</span>, <span class="string">"Howard"</span>)</span><br><span class="line"><span class="comment"># 输出为:</span></span><br><span class="line"><span class="comment">#I make decorators! And I accept arguments: Leonard Sheldon</span></span><br><span class="line"><span class="comment">#I am the decorator. Somehow you passed me arguments: Leonard Sheldon</span></span><br><span class="line"><span class="comment">#I am the wrapper around the decorated function. </span></span><br><span class="line"><span class="comment">#I can access all the variables </span></span><br><span class="line"><span class="comment">#   - from the decorator: Leonard Sheldon </span></span><br><span class="line"><span class="comment">#   - from the function call: Rajesh Howard </span></span><br><span class="line"><span class="comment">#Then I can pass them to the decorated function</span></span><br><span class="line"><span class="comment">#I am the decorated function and only knows about my arguments: Rajesh Howard</span></span><br></pre></td></tr></table></figure></p><p>这就是它了：带参数的装饰器。参数可以使用变量来设定<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">c1 = <span class="string">"Penny"</span></span><br><span class="line">c2 = <span class="string">"Leslie"</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@decorator_maker_with_arguments("Leonard", c1)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorated_function_with_arguments</span><span class="params">(function_arg1, function_arg2)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> (<span class="string">"I am the decorated function and only knows about my arguments:"</span></span><br><span class="line">           <span class="string">" &#123;0&#125; &#123;1&#125;"</span>.format(function_arg1, function_arg2))</span><br><span class="line"></span><br><span class="line">decorated_function_with_arguments(c2, <span class="string">"Howard"</span>)</span><br><span class="line"><span class="comment"># 输出为:</span></span><br><span class="line"><span class="comment">#I make decorators! And I accept arguments: Leonard Penny</span></span><br><span class="line"><span class="comment">#I am the decorator. Somehow you passed me arguments: Leonard Penny</span></span><br><span class="line"><span class="comment">#I am the wrapper around the decorated function. </span></span><br><span class="line"><span class="comment">#I can access all the variables </span></span><br><span class="line"><span class="comment">#   - from the decorator: Leonard Penny </span></span><br><span class="line"><span class="comment">#   - from the function call: Leslie Howard </span></span><br><span class="line"><span class="comment">#Then I can pass them to the decorated function</span></span><br><span class="line"><span class="comment">#I am the decorated function and only knows about my arguments: Leslie Howard</span></span><br></pre></td></tr></table></figure></p><p>正如你看到的那样，你可以使用这个技巧像给函数传递参数一样给装饰器传递参数。如果你想，你甚至可以使用 <code>*args, **kwargs</code>。但是记住装饰器只会被调用<strong>一次</strong>。仅仅当Python载入(imports)这个脚本的时候调用。之后你不可以动态的设定参数。当你 “import x”的时候, <strong>这个函数已经被装饰了</strong>,因此你不能再改变任何东西了。</p><h1 id="让我们来练习一下-装饰一个装饰器"><a href="#让我们来练习一下-装饰一个装饰器" class="headerlink" title="让我们来练习一下:装饰一个装饰器"></a>让我们来练习一下:装饰一个装饰器</h1><p>好了，作为福利，我将给你一个代码片段,它可以让装饰器接收任何参数。<br>为了能接收参数，我们使用另一个函数来创建我们的装饰器。<br>我们封装了装饰器。<br>我们最近知道的能封装函数的东西是什么？<br>对，就是装饰器<br>让我们来写一个装饰装饰器的装饰器来玩玩(够绕吧)：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator_with_args</span><span class="params">(decorator_to_enhance)</span>:</span> </span><br><span class="line">    <span class="string">"""  </span></span><br><span class="line"><span class="string">    这个函数被当做装饰器来使用。  </span></span><br><span class="line"><span class="string">    它必须装饰另一个函数，这个函数也被当做装饰器使用</span></span><br><span class="line"><span class="string">    感觉理解不过来，休息一下</span></span><br><span class="line"><span class="string">    它允许任何的装饰器接收任何参数。</span></span><br><span class="line"><span class="string">    在你的脑子里面记住每次应该怎样构建这样的装饰器</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 我们使用相同的技巧来传递参数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorator_maker</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 我们动态的创建一个接收一个函数作为参数的装饰器  </span></span><br><span class="line">        <span class="comment"># 保持住从decorator_maker传递过来的参数。</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">decorator_wrapper</span><span class="params">(func)</span>:</span></span><br><span class="line">       </span><br><span class="line">            <span class="comment"># 我们最后返回原始装饰器的结果，  </span></span><br><span class="line">            <span class="comment"># 这个结果就是最原始被装饰的函数 (就是返回一个函数)。</span></span><br><span class="line">            <span class="comment"># 这里只有一个小缺陷：被封装的装饰器必须具有特定的签名，不然它不会工作</span></span><br><span class="line">            <span class="keyword">return</span> decorator_to_enhance(func, *args, **kwargs)这个样子</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> decorator_wrapper</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> decorator_maker</span><br></pre></td></tr></table></figure></p><p>它可以像下面这样使用:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 你创建一个将要被用作装饰器的函数。并向它添加一个装饰器(这里是指decorator_with_args) :-)</span></span><br><span class="line"><span class="comment"># 不要忘了你创建的这个装饰器签名必须是 "decorator(func, *args, **kwargs)"</span></span><br><span class="line"><span class="meta">@decorator_with_args </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorated_decorator</span><span class="params">(func, *args, **kwargs)</span>:</span> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(function_arg1, function_arg2)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Decorated with"</span>, args, kwargs</span><br><span class="line">        <span class="keyword">return</span> func(function_arg1, function_arg2)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="comment"># 之后你使用上面定义的装饰器(指decorated_decorator)来装饰一个函数</span></span><br><span class="line"><span class="meta">@decorated_decorator(42, 404, 1024)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorated_function</span><span class="params">(function_arg1, function_arg2)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Hello"</span>, function_arg1, function_arg2</span><br><span class="line"></span><br><span class="line">decorated_function(<span class="string">"Universe and"</span>, <span class="string">"everything"</span>)</span><br><span class="line"><span class="comment"># 输出为:</span></span><br><span class="line"><span class="comment">#Decorated with (42, 404, 1024) &#123;&#125;</span></span><br><span class="line"><span class="comment">#Hello Universe and everything</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 喔!</span></span><br></pre></td></tr></table></figure></p><p>我知道，你有了这样一种感觉，它是在听一一个家伙说:”before understanding recursion, you must first understand recursion”产生的。但是，现在，你是否有更好的体会了？</p><h1 id="最佳实践-装饰器"><a href="#最佳实践-装饰器" class="headerlink" title="最佳实践: 装饰器"></a>最佳实践: 装饰器</h1><ul><li>装饰器是Python2.4引入的，因此保证你的代码运行的版本 &gt;;= 2.4。</li><li>装饰器会拖慢函数的执行速度,记住这点。</li><li><strong>你不能反装饰一个函数。</strong>因此一旦一个函数被装饰了，它<strong>对所有其它代码</strong>来说就都是被装饰了的。</li><li>装饰器会封装函数，这会让它们变得更难调试。 (这点从Python &gt;;= 2.5版本变得好了起来; 具体参考下面。)</li></ul><p>在Python 2.5中 <code>functools</code>模块被引入。它包含了<code>functools.wraps()</code>函数，这个函数会将被装饰函数的名称、模块、文档字符串拷贝到封装函数。<br>(有趣的事实是:<code>functools.wraps()</code> 也是一个装饰器! ☺)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 为了调试，在堆栈轨迹中打印了函数的名称(__name__)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"foo"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> foo.__name__</span><br><span class="line"><span class="comment"># 输出为 : foo</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 有了装饰器，名称就凌乱了 </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"bar"</span></span><br><span class="line">        <span class="keyword">return</span> func()</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@bar</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"foo"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> foo.__name__</span><br><span class="line"><span class="comment"># 输出为: wrapper</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># "functools"对这个有帮助</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="comment"># 我们看到"wrapper"封装了"func"</span></span><br><span class="line">    <span class="comment"># 现在魔法开始了</span></span><br><span class="line"><span class="meta">    @functools.wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"bar"</span></span><br><span class="line">        <span class="keyword">return</span> func()</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@bar</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"foo"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> foo.__name__</span><br><span class="line"><span class="comment"># 输出为: foo</span></span><br></pre></td></tr></table></figure><h1 id="装饰器可以被用在什么地方"><a href="#装饰器可以被用在什么地方" class="headerlink" title="装饰器可以被用在什么地方?"></a>装饰器可以被用在什么地方?</h1><p><strong>现在问题来了:</strong>我可以使用装饰器来干什么?<br>尽管看起来很酷很强大，但是一个实际的应用事例能更好的说明问题。好了，这里有1000种可能性。经典的使用是在库以外的代码中扩展一个函数的行为 (你不能修改的函数)，或者只是为了调试 (因为调试只是零时的，所有你不想修改这个函数)。<br>你可以以一种DRY的方式使用他们来扩展许多函数，像这样:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">benchmark</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    打印原函数调用时间的装饰器</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">import</span> time</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        t = time.clock()</span><br><span class="line">        res = func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">print</span> func.__name__, time.clock()-t</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logging</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    记录脚本行为日志的装饰器  </span></span><br><span class="line"><span class="string">    (这里只是打印它，但是也可以记录到日志里面！)</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        res = func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">print</span> func.__name__, args, kwargs</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">counter</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    记录并打印一个函数执行次数的装饰器</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        wrapper.count = wrapper.count + <span class="number">1</span></span><br><span class="line">        res = func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"&#123;0&#125; has been used: &#123;1&#125;x"</span>.format(func.__name__, wrapper.count)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    wrapper.count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@counter</span></span><br><span class="line"><span class="meta">@benchmark</span></span><br><span class="line"><span class="meta">@logging</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverse_string</span><span class="params">(string)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> str(reversed(string))</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> reverse_string(<span class="string">"Able was I ere I saw Elba"</span>)</span><br><span class="line"><span class="keyword">print</span> reverse_string(<span class="string">"A man, a plan, a canoe, pasta, heros, rajahs, a coloratura, maps, snipe, percale, macaroni, a gag, a banana bag, a tan, a tag, a banana bag again (or a camel), a crepe, pins, Spam, a rut, a Rolo, cash, a jar, sore hats, a peon, a canal: Panama!"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#输出为:</span></span><br><span class="line"><span class="comment">#reverse_string ('Able was I ere I saw Elba',) &#123;&#125;</span></span><br><span class="line"><span class="comment">#wrapper 0.0</span></span><br><span class="line"><span class="comment">#wrapper has been used: 1x </span></span><br><span class="line"><span class="comment">#ablE was I ere I saw elbA</span></span><br><span class="line"><span class="comment">#reverse_string ('A man, a plan, a canoe, pasta, heros, rajahs, a coloratura, maps, snipe, percale, macaroni, a gag, a banana bag, a tan, a tag, a banana bag again (or a camel), a crepe, pins, Spam, a rut, a Rolo, cash, a jar, sore hats, a peon, a canal: Panama!',) &#123;&#125;</span></span><br><span class="line"><span class="comment">#wrapper 0.0</span></span><br><span class="line"><span class="comment">#wrapper has been used: 2x</span></span><br><span class="line"><span class="comment">#!amanaP :lanac a ,noep a ,stah eros ,raj a ,hsac ,oloR a ,tur a ,mapS ,snip ,eperc a ,)lemac a ro( niaga gab ananab a ,gat a ,nat a ,gab ananab a ,gag a ,inoracam ,elacrep ,epins ,spam ,arutaroloc a ,shajar ,soreh ,atsap ,eonac a ,nalp a ,nam A</span></span><br></pre></td></tr></table></figure></p><p>当然，装饰器最好的一点是你不需要重写，就可以几乎在任何东西上面使用它们。这就是我所说的，DRY:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@counter</span></span><br><span class="line"><span class="meta">@benchmark</span></span><br><span class="line"><span class="meta">@logging</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_random_futurama_quote</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">from</span> urllib <span class="keyword">import</span> urlopen</span><br><span class="line">    result = urlopen(<span class="string">"http://subfusion.net/cgi-bin/quote.pl?quote=futurama"</span>).read()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        value = result.split(<span class="string">"&lt;br&gt;;&lt;b&gt;;&lt;hr&gt;;&lt;br&gt;;"</span>)[<span class="number">1</span>].split(<span class="string">"&lt;br&gt;;&lt;br&gt;;&lt;hr&gt;;"</span>)[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> value.strip()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"No, I'm ... doesn't!"</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">print</span> get_random_futurama_quote()</span><br><span class="line"><span class="keyword">print</span> get_random_futurama_quote()</span><br><span class="line"></span><br><span class="line"><span class="comment">#outputs:</span></span><br><span class="line"><span class="comment">#get_random_futurama_quote () &#123;&#125;</span></span><br><span class="line"><span class="comment">#wrapper 0.02</span></span><br><span class="line"><span class="comment">#wrapper has been used: 1x</span></span><br><span class="line"><span class="comment">#The laws of science be a harsh mistress.</span></span><br><span class="line"><span class="comment">#get_random_futurama_quote () &#123;&#125;</span></span><br><span class="line"><span class="comment">#wrapper 0.01</span></span><br><span class="line"><span class="comment">#wrapper has been used: 2x</span></span><br><span class="line"><span class="comment">#Curse you, merciful Poseidon!</span></span><br></pre></td></tr></table></figure></p><p>Python语言本身提供了好多种装饰器：<code>property</code>, <code>staticmethod</code>,等等。</p><ul><li>Django使用装饰器来管理缓存和视图权限。</li><li>Twisted to fake inlining asynchronous functions calls.(对Twisted不熟，不知道具体讲的是神马！)。</li></ul><p>这个真是一个巨大的游乐场</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;转载并整理格式自关于Python-Decorator你应该知道的一切&quot;&gt;&lt;a href=&quot;#转载并整理格式自关于Python-Decorator你应该知道的一切&quot; class=&quot;headerlink&quot; title=&quot;转载并整理格式自关于Python Decorat
      
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记——你当像鸟飞往你的山</title>
    <link href="http://yoursite.com/2021/04/21/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E4%BD%A0%E5%BD%93%E5%83%8F%E9%B8%9F%E9%A3%9E%E5%BE%80%E4%BD%A0%E7%9A%84%E5%B1%B1/"/>
    <id>http://yoursite.com/2021/04/21/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E4%BD%A0%E5%BD%93%E5%83%8F%E9%B8%9F%E9%A3%9E%E5%BE%80%E4%BD%A0%E7%9A%84%E5%B1%B1/</id>
    <published>2021-04-21T01:28:45.000Z</published>
    <updated>2021-08-04T07:10:32.783Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://images-cn.ssl-images-amazon.cn/images/I/41-NCBPI5pL.jpg" align="center"></p><blockquote><p>作者: <a href="https://book.douban.com/search/塔拉·韦斯特弗" target="_blank" rel="noopener">[美] 塔拉·韦斯特弗</a><br>出版社: 南海出版公司<br>出品方: <a href="https://book.douban.com/series/39059?brand=1" target="_blank" rel="noopener">新经典文化</a><br>原作名: Educated:A Memoir<br>译者: <a href="https://book.douban.com/search/任爱红" target="_blank" rel="noopener">任爱红</a><br>出版年: 2019-10</p></blockquote><div class="note info"><p>210407</p></div><p><strong>⭕️  “我不知道他为什么这么做，他也不知道。他无法解释这个信念从何而来，也无法解释它是如何发出明亮的光来穿透那黑暗的不确定。但我一直猜想那来自他脑海中的音乐，来自我们其他人听不到的充满希望的曲调，来自他买三角学书和收藏铅笔屑时一直哼唱的秘密旋律”</strong></p><div class="note info"><p>210414</p></div><p><strong>⭕️ “我在学习的这个技能至关重要，那就是对不懂的东西耐心阅读”</strong></p><p><strong>⭕️  “外面有一个世界，塔拉，”他说，“一旦爸爸不再在你耳边灌输他的观点，世界就会看起来大不一样。”</strong></p><div class="note info"><p>210420</p></div><p><strong>⭕️ “我只是站着，”我说，“你们却都降低身体，试图弥补，因为高处让你们害怕。但蹲着走和侧身走并不自然，这样反而让自己变得脆弱。如果能控制住恐慌，这风就不值一提了。”</strong></p><p><strong>⭕️ “决定你是谁的最强大因素来自你的内心。”</strong></p><div class="note info"><p>210421</p></div><p><strong>⭕️ “我的羞耻感源自我有一个将我朝吱嘎作响的大剪刀刀刃推去，而不是将我拉走远离它们的父亲；我的羞耻感源自我躺在地上的那些时刻，源自知道母亲就在隔壁房间闭目塞听，那一刻完全没有选择去尽一个母亲的责任。”</strong></p><p><strong>⭕️ “过去是一个幽灵，虚无缥缈，没什么影响力。只有未来才有分量。”</strong></p><p><strong>⭕️ “评价多种思想、多种历史和多种观点的能力是自我创造力的核心。”</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://images-cn.ssl-images-amazon.cn/images/I/41-NCBPI5pL.jpg&quot; align=&quot;center&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;作者: &lt;a href=&quot;https://book.
      
    
    </summary>
    
    
      <category term="Reading" scheme="http://yoursite.com/categories/Reading/"/>
    
    
      <category term="Reading" scheme="http://yoursite.com/tags/Reading/"/>
    
  </entry>
  
  <entry>
    <title>MacOS下OpenCV + Python+PyQt5多进程Bug</title>
    <link href="http://yoursite.com/2021/04/12/MacOS%E4%B8%8BOpenCV+Python+PyQt5%E5%A4%9A%E8%BF%9B%E7%A8%8BBug/"/>
    <id>http://yoursite.com/2021/04/12/MacOS%E4%B8%8BOpenCV+Python+PyQt5%E5%A4%9A%E8%BF%9B%E7%A8%8BBug/</id>
    <published>2021-04-12T15:52:25.000Z</published>
    <updated>2021-04-12T15:54:44.584Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MacOS下OpenCV-Python-PyQt5-多进程Bug"><a href="#MacOS下OpenCV-Python-PyQt5-多进程Bug" class="headerlink" title="MacOS下OpenCV + Python+PyQt5 多进程Bug"></a>MacOS下OpenCV + Python+PyQt5 多进程Bug</h1><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul><li>macOS  Catalina 10.15.7</li><li>pyqt5</li><li>opencv</li></ul><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul><li>多进程情况下<code>cv2.resize</code>或者<code>cv2.cvtColor</code>引发程序崩溃</li><li>使用PyQt5与opencv的冲突</li></ul><h2 id="可能的解决方案"><a href="#可能的解决方案" class="headerlink" title="可能的解决方案"></a>可能的解决方案</h2><ol><li>安装<code>opencv-python-headless</code>替换<code>opencv-python</code></li><li>设置 <code>cv2.setNumThreads(0)</code></li></ol><blockquote><p>OpenCV will try to set the number of threads for the next parallel region. If <code>threads == 0</code>, OpenCV will disable threading optimizations and run all its functions sequentially. Passing <code>threads &lt; 0</code> will reset threads number to system default. This function must be called outside of parallel region.</p></blockquote><ol><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing <span class="keyword">as</span> mp</span><br><span class="line">mp.set_start_method(<span class="string">'spawn'</span>)</span><br></pre></td></tr></table></figure></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/qq_32815807?spm=1010.2135.3001.5343" target="_blank" rel="noopener">OpenCV + Python multiprocessing breaks on OSX</a></p><p><a href="https://stackoverflow.com/questions/54013846/pytorch-dataloader-stucked-if-using-opencv-resize-method" target="_blank" rel="noopener">pytorch dataloader stucked if using opencv resize method</a></p><p><a href="https://github.com/opencv/opencv/issues/18416" target="_blank" rel="noopener">OpenCV 4.4.0.44 macOS Catalina - Hang/Frozen</a></p><h1 id><a href="#" class="headerlink" title=" "></a> </h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MacOS下OpenCV-Python-PyQt5-多进程Bug&quot;&gt;&lt;a href=&quot;#MacOS下OpenCV-Python-PyQt5-多进程Bug&quot; class=&quot;headerlink&quot; title=&quot;MacOS下OpenCV + Python+PyQt5 
      
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>旋转矩阵计算角度差</title>
    <link href="http://yoursite.com/2021/04/01/%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5%E8%AE%A1%E7%AE%97%E8%A7%92%E5%BA%A6%E5%B7%AE/"/>
    <id>http://yoursite.com/2021/04/01/%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5%E8%AE%A1%E7%AE%97%E8%A7%92%E5%BA%A6%E5%B7%AE/</id>
    <published>2021-04-01T11:31:24.000Z</published>
    <updated>2021-04-01T11:36:58.677Z</updated>
    
    <content type="html"><![CDATA[<h1 id="旋转矩阵计算角度差"><a href="#旋转矩阵计算角度差" class="headerlink" title="旋转矩阵计算角度差"></a>旋转矩阵计算角度差</h1><h2 id="根据旋转矩阵的估计值和真值计算角度误差"><a href="#根据旋转矩阵的估计值和真值计算角度误差" class="headerlink" title="根据旋转矩阵的估计值和真值计算角度误差"></a>根据旋转矩阵的估计值和真值计算角度误差</h2><p>论文 Benchmarking 6DOF Outdoor Visual Localization in Changing Conditions中公式</p><script type="math/tex; mode=display">R_{gt}$$真值   $$R_{est}$$估计值  二维矩阵形式$$2 \cos (|\alpha|)=\operatorname{trace}\left(\mathrm{R}_{\mathrm{gt}}^{-1} \mathrm{R}_{\mathrm{est}}\right)-1</script><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rot_error</span><span class="params">(r_gt,r_est)</span>:</span></span><br><span class="line">    dis = abs(math.acos((np.trace(np.dot(np.linalg.inv(r_gt),r_est))<span class="number">-1</span>)/<span class="number">2</span>)) </span><br><span class="line">    <span class="comment">#公式计算结果单位为弧度，转成角度返回</span></span><br><span class="line">    <span class="keyword">return</span> dis*<span class="number">180</span>/math.pi</span><br></pre></td></tr></table></figure><hr><p>3维旋转矩阵计算角度差得到角度差矩阵</p><p>r_gt_matrix,r_est_matrix 3维矩阵</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rot_error_matrix</span><span class="params">(r_gt_matrix,r_est_matrix)</span>:</span></span><br><span class="line">  <span class="keyword">return</span> (np.abs(np.arccos(np.clip((np.trace(np.einsum(<span class="string">"ahw,bjk-&gt;abhk"</span>, np.linalg.inv(r_gt_matrix),r_est_matrix),axis1=<span class="number">2</span>,axis2=<span class="number">3</span>)<span class="number">-1</span>)/<span class="number">2</span>,<span class="number">-1</span>,<span class="number">1</span>)))*<span class="number">180</span>/math.pi)</span><br></pre></td></tr></table></figure><h2 id="E-G"><a href="#E-G" class="headerlink" title="E.G."></a>E.G.</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">from</span> einops <span class="keyword">import</span> rearrange, reduce, repeat</span><br><span class="line"></span><br><span class="line">r_gt=np.array([[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>],[<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>]])</span><br><span class="line">r_est=np.array([[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>]])</span><br><span class="line"></span><br><span class="line">r_gt_matrix = repeat(r_gt,<span class="string">'i j -&gt; c i j'</span>,c=<span class="number">4</span>)</span><br><span class="line">r_est_matrix = repeat(r_est,<span class="string">'i j -&gt; c i j'</span>,c=<span class="number">5</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>rot_error(r_gt,r_est)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">180.0</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>rot_error_matrix((r_gt_matrix,r_est_matrix))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>array([[<span class="number">180.</span>, <span class="number">180.</span>, <span class="number">180.</span>, <span class="number">180.</span>, <span class="number">180.</span>],</span><br><span class="line">        [<span class="number">180.</span>, <span class="number">180.</span>, <span class="number">180.</span>, <span class="number">180.</span>, <span class="number">180.</span>],</span><br><span class="line">        [<span class="number">180.</span>, <span class="number">180.</span>, <span class="number">180.</span>, <span class="number">180.</span>, <span class="number">180.</span>],</span><br><span class="line">        [<span class="number">180.</span>, <span class="number">180.</span>, <span class="number">180.</span>, <span class="number">180.</span>, <span class="number">180.</span>]])</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/qq_37666812/article/details/107723682" target="_blank" rel="noopener">根据旋转矩阵计算角度差</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;旋转矩阵计算角度差&quot;&gt;&lt;a href=&quot;#旋转矩阵计算角度差&quot; class=&quot;headerlink&quot; title=&quot;旋转矩阵计算角度差&quot;&gt;&lt;/a&gt;旋转矩阵计算角度差&lt;/h1&gt;&lt;h2 id=&quot;根据旋转矩阵的估计值和真值计算角度误差&quot;&gt;&lt;a href=&quot;#根据旋转矩阵
      
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Multipath Excitation for Action Recognition(ACTION-Net)</title>
    <link href="http://yoursite.com/2021/04/01/ACTION-Net%20Multipath%20Excitation%20for%20Action%20Recognition/"/>
    <id>http://yoursite.com/2021/04/01/ACTION-Net%20Multipath%20Excitation%20for%20Action%20Recognition/</id>
    <published>2021-04-01T08:22:22.000Z</published>
    <updated>2021-04-01T08:28:41.036Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ACTION-Net-Multipath-Excitation-for-Action-Recognition"><a href="#ACTION-Net-Multipath-Excitation-for-Action-Recognition" class="headerlink" title="ACTION-Net: Multipath Excitation for Action Recognition"></a>ACTION-Net: Multipath Excitation for Action Recognition</h1><blockquote><p>单位 都柏林圣三一大学、字节跳动</p><p>会议 CVPR 2021</p><p>论文地址 <a href="https://arxiv.org/abs/2103.07372" target="_blank" rel="noopener">arxiv</a></p><p>代码地址 <a href="https://github.com/V-Sense/ACTION-Net" target="_blank" rel="noopener">github</a></p></blockquote><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p><strong>时空特征、通道特征和运动特征是视频动作识别中三种重要信息</strong>。传统的二维CNN计算成本低，但无法捕捉时间关系；三维CNN可以很好捕捉时间关系，但计算量大。在这项工作中，通过设计一个通用且有效的模块来解决这个难题，该模块可以嵌入到二维CNN中。为此，提出了一种时空、通道和运动激励（ACTION）模块，包括三条路径：时空激励（STE）路径、通道激励（CE）路径和运动激励（ME）路径</p><ul><li><p>STE路径采用单通道3D卷积来表征时空表示</p></li><li><p>CE路径通过在时间方面显式地建模通道之间的相互依赖性来自适应地重新校准通道特征响应</p></li><li><p>ME路径计算特征级的时间差，然后利用这些时间差来激励运动敏感通道</p></li></ul><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p><strong>视频中的复杂动作通常是时间相关的，它不仅包含每一帧的空间信息，而且还包含一段时间内的时间信息</strong>。传统的动作识别更多的是场景相关的，其中的动作没有时间依赖性，例如，“上眼妆”，“走路”，“跑步”。随着技术的飞速发展，如虚拟现实（VR）等需要利用特征与环境进行交互的技术，时间相关的动作识别近年来成为研究的热点。</p><p>现有方法的主流是基于三维CNN和基于二维CNN。3D CNN已被证明在时空建模方面是有效的，但时空建模无法捕获视频中包含的足够信息。提出的双流体系结构将时空信息和光流纳入计算，<strong>与单流体系结构相比显著提高了性能。然而，光流的计算非常昂贵，这给实际应用带来了挑战。三维CNN存在过拟合和收敛速度慢等问题</strong>。</p><p>随着更多大规模数据集的发布，如Kinetics、Moments in Time和ActivityNet，优化3D CNN变得更加容易和普及。<strong>然而，基于3D CNN固有的繁重计算导致推断速度缓慢，这将限制它们在实际应用中的部署，例如依靠在线视频识别的虚拟现实。当前基于2D CNN的方法有着轻量级和快速推理的优势</strong>。这些方法基于从整个视频中稀疏采样的一系列短片段（称为片段），最初在TSN中引入。原始的二维cnn缺乏时间建模能力，这导致在某些操作中丢失了必要的序列信息，例如“打开一个盒子”与“关闭一个盒子”。<strong>TSM通过在时间轴上移动一部分通道，将时间信息引入到基于2D CNN的框架中，这显著改善了基于2D CNN的框架的基线。然而，TSM仍然缺乏明确的动作时间模型，例如运动信息</strong>。</p><p>最近的工作根据ResNet架构将嵌入式模块引入到2d cnns中，具有运动建模的能力。为了捕捉视频中包含的多种类型的信息，以前的工作通常在输入级帧上进行。例如，SlowFast网络以多种速率对原始视频进行采样，以描述慢动作和快动作；双流网络利用预先计算的光流来推理运动信息。这种方法通常需要多分支网络，这需要昂贵的计算。</p><p>受上述观察结果的启发，提出了一种新的即插即用、轻量级的时空、通道和运动激励（ACTION）模块，<strong>通过采用多径激励在单个网络中有效地处理特征层上的多种类型信息。时空特征和运动特征的组合可以类似地理解为双流结构，但是基于特征级别对网络内部的运动进行建模，而不是生成另一种类型的输入（例如，光流）来训练网络，这大大减少了计算量</strong>。受SENet的启发，基于时域提取通道特征来表征网络的通道相关性。相应地，配备了这样一个模块的新体系结构被称为ActionNet。</p><h2 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h2><h3 id="基于-3D-CNN"><a href="#基于-3D-CNN" class="headerlink" title="基于 3D CNN"></a>基于 3D CNN</h3><p>基于3D CNN的框架具有时空建模能力，提高了视频动作识别的模型性能。I3D将ImageNet预先训练的2D核膨胀为3D核，用于捕获时空信息。为了更好地表示运动模式，I3D利用了预先计算的光流和RGB（也称为双流结构）。SlowFast 网络被提出用于处理视频中动作的不稳定速度，例如跑步和步行，它分别涉及一个慢分支和一个快分支来模拟慢动作和快动作。尽管基于3D CNN的方法在多个基准数据集上取得了令人兴奋的结果，但它们包含大量参数。</p><p><strong>在这种情况下，会产生各种各样的问题，例如容易过度拟合和难以收敛，这带来了挑战，包括在真实应用中在线流视频的低效率的推断。尽管最近的工作已经证明三维卷积可以分解以在一定程度上减少计算，但是与基于二维CNN的框架相比，计算仍然是一个更大的负担。</strong></p><h3 id="基于2D-CNN"><a href="#基于2D-CNN" class="headerlink" title="基于2D CNN"></a>基于2D CNN</h3><p>TSN是第一个提出的将2D CNN应用于视频动作识别的框架，该框架引入了“片段”的概念来处理视频，即使用单一形式的稀疏采样方案在长视频序列上提取短片段。然而，直接使用2dcnns缺乏对视频序列的时域建模。TSM首先将时态建模引入到基于二维CNN的框架中，将一部分通道的移位操作嵌入到二维CNN中。然而，TSM缺乏明确的动作时间建模，例如相邻帧之间的差异。最近，有几项工作建议将模块嵌入到二维CNNs中。这些模块能够模拟运动和节奏信息。例如，MFNet、TEINet和TEA引入了这种类型的模块，它们在ResNet架构上被证明是有效的。STM提出了一种用于时空和运动信息建模的块，而不是普通的残差块。GSM利用组空间选通来控制时空分解中的交互。</p><h3 id="SENet-和改进"><a href="#SENet-和改进" class="headerlink" title="SENet 和改进"></a>SENet 和改进</h3><p>Hu等人介绍了一种SENet体系结构。提出在二维CNN中嵌入squeeze-and-excitation（SE）块。在这种情况下，通过显式地建模通道相互依赖性，可以增强有关图像识别任务的通道特征的学习。为了解决这个问题，SE块以squeeze-and-unsqueeze方式利用两个全连接的层，然后应用Sigmoid激活函数来激发基本的通道特性。但是，它独立地处理每个图像，而不考虑关键信息，如视频的时间特性。为了解决这个问题，TEA引入了运动激励（ME）和多重时间聚集（MTA）来捕捉短期和长期的时间演化。需要注意的是，MTA是专门为Res2Net设计的，这意味着TEA只能嵌入Res2Net中。<strong>受前两个工作的启发，提出了STE和CE模块，解决时空和通道在时间维度上的相互依赖性。Action模块由STE、CE和ME并行组装而成，可以激活视频中的多种类型信息。</strong></p><h2 id="ACTION的设计"><a href="#ACTION的设计" class="headerlink" title="ACTION的设计"></a>ACTION的设计</h2><p>ACTION模块由时空激励（STE）、通道激励（CE）和运动激励（ME）三个子模块组成</p><p>整体ACTION模块分别对STE、CE和ME生成的三个激励特征进行元素级的相加。通过这样做ACTION模块的输出可以获得时空信息、通道间依赖信息和运动信息。图3显示了ResNet-50的ACTION-Net架构，其中ACTION模块插入到每个残差块的开头。它不需要对块中的原始组件进行任何修改。</p><p><img src="https://img-blog.csdnimg.cn/20210401161639523.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyODE1ODA3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="时空激励-STE"><a href="#时空激励-STE" class="headerlink" title="时空激励 (STE)"></a>时空激励 (STE)</h3><p><img src="https://img-blog.csdnimg.cn/20210401161733270.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyODE1ODA3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><p>对输入X (N×T×C×H×W)通道平均池化得到F(N×T×1×H×W)</p></li><li><p>改变F维度为N×1×T×H×W</p></li><li><p>经过3×3×3的3D卷积中得到$F^∗ (N×1×T×H×W)$</p></li><li><p>将$F^∗$ 改变维度得到$F_o (N×T×1×H×W)$</p></li><li><p>$F_o$ 经过Sigmoid激活得到mask M(N×T×1×H×W)</p></li><li><p>输入X经过M⨀X+X激励得到输出</p></li></ul><h3 id="通道激励-CE"><a href="#通道激励-CE" class="headerlink" title="通道激励(CE)"></a>通道激励(CE)</h3><p><img src="https://img-blog.csdnimg.cn/20210401161748591.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyODE1ODA3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><p>对输入X (N×T×C×H×W)在空间平均池化得到F(N×T×C×1×1)</p></li><li><p>使用1×1卷积来压缩 F的通道数得到特征 $F_r (N×T×C/r×1×1)$</p></li><li><p>改变 $F_r$ 维度得到$F_r^{*} (N×C/r×T×1×1)$</p></li><li><p>经过卷积核为3的一维卷积后得到 $F_{temp}^{*} (N×C/r×T×1×1)$</p></li><li><p>改变$ F<em>{temp}^{*}$ 维度为 $F</em>{temp} (N×T×C/r×1×1)$</p></li><li><p>经过1×1卷积得到$ F_o (N ×T ×C ×1 ×1) $</p></li><li><p>$F_o$经过Sigmoid激活,得到mask M(N ×T ×C×1×1)</p></li><li><p>输入X经过M⨀X+X激励得到输出</p></li></ul><h3 id="运动激励-ME"><a href="#运动激励-ME" class="headerlink" title="运动激励(ME)"></a>运动激励(ME)</h3><p><img src="https://img-blog.csdnimg.cn/20210401161801914.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyODE1ODA3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><p>输入X (N×T×C×H×W)经过1×1卷积压缩得到 $F_r (N×T×C/r×H×W)$</p></li><li><p>计算各帧的运动特征 K是3×3卷积</p></li></ul><p>$F_m=K∗F_r [:,t+1,:,:,:]-F_r [:,t,:,:,:]$</p><ul><li><p>根据时间维度将运动特征串联得到$F_M (N×T×C/r×H×W)$</p><p>$F_M=[F_m (1),⋯,F_m (t-1), 0]$</p></li><li><p>$F_M$经过空间平均池化得到$F_o (N ×T ×C/r×1 ×1) $</p></li><li><p>再经过1×1卷积， Sigmoid激活后得到mask M</p></li><li><p>输入X经过M⨀X+X激励得到输出</p></li></ul><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><h3 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h3><div class="table-container"><table><thead><tr><th><strong>数据集</strong></th><th><strong>介绍</strong></th><th><strong>行为数</strong></th><th><strong>训练集</strong></th><th><strong>验证集</strong></th><th><strong>测试集</strong></th></tr></thead><tbody><tr><td>Something-Something  V2</td><td>人与日常生活中物体交互的动作数据集</td><td>174</td><td>168,913</td><td>24,777</td><td>27,157</td></tr><tr><td>Jester</td><td>第三人称视角的手势数据集</td><td>27</td><td>118,562</td><td>14,787</td><td>14,743</td></tr><tr><td>EgoGesture</td><td>头戴式摄像机记录的手势数据集</td><td>83</td><td>14,416</td><td>4768</td><td>4977</td></tr></tbody></table></div><hr><ul><li><p>在Jester和EgoGesture上取得了SOTA</p></li><li><p>在Something V2上相比较STM和TEA也取得了接近的效果</p></li></ul><p><img src="https://img-blog.csdnimg.cn/20210401161829638.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyODE1ODA3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><hr><h3 id="消融实验"><a href="#消融实验" class="headerlink" title="消融实验"></a>消融实验</h3><ul><li><p>动作激励相比时空激励和通道激励对性能提升最大</p></li><li><p>时空激励在更小的计算量和参数量下性能提升和通道激励相当</p></li></ul><p><img src="https://img-blog.csdnimg.cn/20210401161842989.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyODE1ODA3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><hr><p><strong>ACTION-Net在不同主干网络都带来了性能提升，具有良好的通用性</strong></p><p><img src="https://img-blog.csdnimg.cn/20210401161852833.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyODE1ODA3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><strong>提出了一个即插即用、轻量级的时空、通道和运动激励模块（ACTION）</strong></li><li><strong>采用了多路径激励的方法有效地捕获时空特征、通道特征和运动特征</strong></li><li><strong>提出的ACTION模块可以被任何二维卷积模型用来构建视频动作识别网络</strong></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ACTION-Net-Multipath-Excitation-for-Action-Recognition&quot;&gt;&lt;a href=&quot;#ACTION-Net-Multipath-Excitation-for-Action-Recognition&quot; class=&quot;hea
      
    
    </summary>
    
    
      <category term="Paper" scheme="http://yoursite.com/categories/Paper/"/>
    
    
      <category term="Paper" scheme="http://yoursite.com/tags/Paper/"/>
    
      <category term="ActionRecognition" scheme="http://yoursite.com/tags/ActionRecognition/"/>
    
  </entry>
  
  <entry>
    <title>知识图谱内容调研</title>
    <link href="http://yoursite.com/2021/03/03/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E5%86%85%E5%AE%B9%E8%B0%83%E7%A0%94/"/>
    <id>http://yoursite.com/2021/03/03/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E5%86%85%E5%AE%B9%E8%B0%83%E7%A0%94/</id>
    <published>2021-03-03T02:42:28.000Z</published>
    <updated>2021-03-03T02:43:10.830Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="知识图谱内容调研"><a href="#知识图谱内容调研" class="headerlink" title="知识图谱内容调研"></a>知识图谱内容调研</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><pre><code>    知识图谱的本质是揭示实体之间关系的语义网络。利用实体和关系来表达客观世界的对象以及不同对象之间存在的关系，提供了组织、管理和理解海量非结构化信息的能力，且对信息的刻画方式更接近于人类认知世界的形式。例如，实体“《静夜思》”和实体“李白”之间存在关系“创作者”，其结点代表实体（Entity）或者概念（Concept），边代表实体或概念之间的各种语义关系。</code></pre><h2 id="解决什么问题"><a href="#解决什么问题" class="headerlink" title="解决什么问题"></a>解决什么问题</h2><pre><code>    由于互联网数据存在着多元异构性和高度动态性，并且内容丰富涉及范围广，不同的数据之间存在复杂的关联性。因此传统的数据存储、管理和查询模式已经无法满足当今人们对知识的需求。**开发者希望能够从海量互联网数据中获取并管理有效的信息，同时让计算机自动理解并分析网络数据中的内容，从而准确、高效的挖掘数据资源中所蕴含的价值信息**。知识图谱技术的提出为更好地组织、管理和理解互联网中的海量信息提供了一种行之有效的解决方案，其知识表达的方法也更接近人类认知世界的形式。        现有的视频目标信息挖掘主要还是人工操作，大部分摄像头所录制的视频只有经过人眼查看才能发现视频中的有效监控信息，面对海量的视频，有限的人力很难避免遗漏视频中的一些重要信息，且耗费了大量的人力，没有展现出很好的智能性。如何**基于海量的视频，构建一套自动化方法，对视频进行信息提取，挖掘视频中潜在的有效信息**，是当今智能化时代的趋势。    基于视频知识库的构建是一个创新性的方法，能够**对大量的视频自动化地提取有效信息**，知识图谱是基于文本的知识库的构建，视频图谱在监控视频上构建语义信息。视频图谱有很高的实际应用价值，比如在公安领域，通过构建视频图谱，能够挖掘出频繁同行的犯罪团伙；在住宅小区或者工厂等小型区域，可以区别常驻人员和外来人员。视频图谱的构建和挖掘研究大大降低了人力成本，系统性地构建了监控视频中的行人、车辆、物品等关系模型，可用于快速信息检索等方面。因此，研究一种基于监控视频的视频图谱构建和挖掘方法具有很高的价值。</code></pre><h2 id="研究现状及发展趋势"><a href="#研究现状及发展趋势" class="headerlink" title="研究现状及发展趋势"></a>研究现状及发展趋势</h2><h3 id="知识图谱构建应用实践"><a href="#知识图谱构建应用实践" class="headerlink" title="知识图谱构建应用实践"></a>知识图谱构建应用实践</h3><pre><code>    在知识图谱发展的早期阶段，知识的来源主要依赖于各种百科全书、网络词典文集和百科网站等结构化数据，并且通过人工协作的方式构建完成，期间具有代表性的工作包括YAGO，DBpedia和Freebase等知识库。由于知识图谱技术的快速普及与应用，少量的结构化数据已无法满足人们的需求，因此现阶段知识图谱中的数据来源主要是互联网海量纯文本等非结构化信息，并采用开放域信息抽取技术自动构建，代表性成果包括谷歌公司的KnowledgeVault和卡耐基梅隆大学的NELL（Never-EndingLanguageLearning）项目等，相关成果如下图</code></pre><p><img src="https://img-blog.csdnimg.cn/20210303102334447.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyODE1ODA3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><pre><code>    国外在知识图谱的构建方面获得的重要进展主要为谷歌公司所开发的Knowledgevault，将维基百科作为基础的Freebase以及DBpedia，其中Freebase将维基百科作为数据来源，并从中抽提结构化数据，借助人工编制的形式完成了2000余万条实体的构造，逐渐成为了Google知识图谱重要构成内容。DBpedia则是由莱比锡大学与曼海姆大学共同开发的跨语言知识库，同样将维基百科作为基本数据来源，使用固定模式将结构化信息抽提出来，采用关联的形式发布信息。DBpedia具备了4000余万条实体和5亿件事实信息。国内当前所发布知识图谱产品包含了百度知心、搜狗知立方以及清华大学所开发的XLore、上海交大开发的Zhishi.me等。    以上这些知识库都是基于网页中的文本数据构建而成的，只能够回答关于文本中的一些相关问题。一些学者也尝试为图像构建知识库，如斯坦福大学李菲菲团队构建的VisualGenome知识库，其使用“众包”方式对108249个图像进行解析，提取了420万个区域描述、170万个可视问答、210万个对象实例、180万个属性和180万个关系。基于该知识库，构建一系列的智能检索和分析应用，如基于场景图（SceneGraph）的图像检索、可视自动问答。和图像标题自动生成等。    现有的知识库主要面向文本数据，面向图像的只有VisualGenome，而面向监控视频数据的知识库仍然空缺。知识库是对原始数据进行语义理解和分析之后的中间结果，相对来说，面向文本的知识库构建更为容易，而图像和视频数据的知识库构建难度更大。鉴于监控视频大数据的数据量之大，很难像VisualGenome一样用“众包”方式构建，因而需要用自动化方式对监控视频进行解析。此外，知识库是为上层智能分析和查询服务，因此面向监控视频大数据的知识库需要紧扣监控视频分析应用需求。</code></pre><h3 id="知识图谱构建技术"><a href="#知识图谱构建技术" class="headerlink" title="知识图谱构建技术"></a>知识图谱构建技术</h3><p>目前知识图谱的构建技术研究基本还是针对文本信息，自然语言的研究。</p><h4 id="命名实体识别技术"><a href="#命名实体识别技术" class="headerlink" title="命名实体识别技术"></a>命名实体识别技术</h4><pre><code>    在进行文本处理之前，需要进行命名实体识别，此时要用到命名实体识别技术，这是自然语言处理的前置任务。伴随着大数据技术以及人工智能技术的持续发展，研究者对于命名实体识别任务所开展的研究工作日益增多，相关技术获得了持续发展，并取得了突出成绩。在应用不断深入的背景下，命名实体识别慢慢成为情感分析、语义检索、自动问答以及机器翻译等研究工作的前提和基础。比如如何从大量非结构化语料文本中自主、精确的将命名实体抽提出来，已经成为了国内外学术界关注的焦点。国外在很早之前就开始了对命名实体识别的研究，并不断深入。目前，国外学者所开展的研究工作更加倾向于采用监督、半监督机械学习方法识别用英文语料文本，针对规则、方法所开展的研究工作已经非常少见。在英文语料文本的识别中经常采用的模型、方法包括了最大熵模型、隐马尔可夫模型、决策树、条件随机等。不同于英文语料文本，中文识别难度较大，国内学者从国外研究成果中抽提出了有效的方法，结合中文的实际情况，对其展开了有效地探索。经常使用的方法通常是人工从语料当中抽提出特征，结合数学模型对其命名实体识别。从研究成果上看，俞鸿魁等人创造性的给出层叠隐马尔可夫模型，把多种实体类型识别融入到了具体的数学模型中，最终结果表明其能够更加容易的发现未登录实体，同时对于复合实体的识别也有一定的促进作用。周俊生将中文实体前后缀作为特征，将条件随机场方法作为基础，对人民日报语料展开了分析，并获得了良好的结果。随着研究的不断深入，更多实验结果表明，条件随机场也能够用于识别中文命名实体，把条件随机场作为前提与基础的命名实体识别技术开始受到了学术界的普遍肯定。</code></pre><h4 id="关系抽提技术"><a href="#关系抽提技术" class="headerlink" title="关系抽提技术"></a>关系抽提技术</h4><pre><code>    在上世纪九十年代，MUC-7率先公布了实体关系抽提相关研究任务，其被看做是信息抽取子任务。伴随着MUC停办，ACE会议完全接替了MUC内容，继续研究以预料文本作为基本内容的自动抽取方法。ACE工作核心为信息抽取，在实际工作的开展进程中需要不断地拓展工作牵涉到的各个领域及不同的语言。这两个会议对于自然语言处理任务中信息抽提的进一步发展有着积极的推动作用。在人工智能、大数据等相关技术的发展背景下，人们将更多的关注点集中在信息抽提技术层面，并且将其看做是信息抽取工作的前置任务，关系抽取也开始得到了诸多学者的广泛关注，他们为了完善与健全关系抽取理论而源源不断地投入精力，共同推动抽提技术的有序发展，在实际应用中广泛应用关系抽取研究成果。关系抽取的对象为非结构化语料文本，目前研究方法包含了基于模型匹配、机器语言以及语义网络等诸多内容。ChinatsuAone等人借助模式匹配思想构建了关系抽提系统，通过人工编写关系抽取规则，保证了文本和抽取规则之间的匹配度，得到了实体关系实例。该系统采用了相对灵活的架构模块，利用规则、模块不断地修改、完善该系统。RomanY构造了Proteus系统，其是一种基于样本泛化的关系抽取模式，用户可以对存在特定类型关系demo展开分析，总结关系特征，并且把关系特征抽象为特定的模型，该系统可以获得良好实验效果。</code></pre><h2 id="现有方案"><a href="#现有方案" class="headerlink" title="现有方案"></a>现有方案</h2><p>调研基于知识图谱的视觉目标关系建模的应用</p><h3 id="一、针对于罪犯的知识图谱构建与应用"><a href="#一、针对于罪犯的知识图谱构建与应用" class="headerlink" title="一、针对于罪犯的知识图谱构建与应用"></a>一、针对于罪犯的知识图谱构建与应用</h3><p><strong>关键词</strong>：挖掘视觉目标潜在语义关联，建立多元化的目标关系图谱，基于知识图谱实现对目标的更高效理解与表达。</p><h4 id="1-涉案实体识别"><a href="#1-涉案实体识别" class="headerlink" title="1.涉案实体识别"></a>1.涉案实体识别</h4><pre><code>    先将监控视频中识别到的罪犯主体的信息标注为词汇，将监控图像中的罪犯信息细分为人名、机构名、地名、时间、日期、货币、交通工具和武器等实体。实体识别分人工识别和自动识别。人工识别相对准确，但效率低，仅适用少量样本的处理。自动识别分为两大类：基于规则的实体识别和基于机器学习的实体识别，机器学习识别又分为基于特征和基于神经网络。基于规则的方法适用于英文环境，国外早期系统均采用此法。基于词典方法依靠匹配规则简单有效，对中文支持较好，但构建词典耗时耗力。机器学习方法则利用已标注的语料库训练模型，使用特定字或词命名实体整体或部分。其后，基于LSTMCRF的深度学习被用于实体识别。由于任务和需求不同，实体识别的粒度也不同。实体识别粒度越小则难度和开销越大，但指导意义更大。当前，困扰实体识别的要素包括实体命名形式多变、语言环境复杂和实体存在歧义等。</code></pre><h4 id="2-实体消歧"><a href="#2-实体消歧" class="headerlink" title="2.实体消歧"></a>2.实体消歧</h4><pre><code>    由于形式和语义复杂，实体识别后需进行一致性校验，即实体消歧。其原因在于：同一实体可能有不同的称谓，同一名称可能表示不同的实体。消歧的一般方法为有监督的机器学习。分类方法通过构建正负实例、指称-实体对等形式通过有监督方式进行学习，获取二元分类模型以实现实体消歧。机器学习排序方法分三类，PointWise使用近似回归模型计算候选匹配实体的得分并排序，得分越高则越倾向为同一实体；PairWise将候选项匹配成对，利用项与项间的相对位置关系构建训练样本，采用分类方法训练排序感知机实现消歧；ListWise则将査询结果排序列表视为训练实例，利用ListNet算法训练排序模型进行消歧。基于图的方法将情报中的实体指称及其候选实体构成图结构，利用两者的关联完成协同消歧。混合模型综合运用多种模型获得各自消歧结果，最后通过比较得到最优结果，效果好于单模型。实体消歧过程要避免实体的遗漏和流失，以免数据失真。</code></pre><h4 id="3-实体关联提取"><a href="#3-实体关联提取" class="headerlink" title="3.实体关联提取"></a>3.实体关联提取</h4><pre><code>    实体关联是构建犯罪知识图谱的核心环节，将监控信息从画面和文字层面上升到内容层面。在犯罪情报方面，实体关系主要体现人(组织)、物或事为中心的两方或多方关联，需要时还可加入时间或地点。其难点在于同一关系表述不同、关系涉及实体多、同一词汇标注表达不同关系和存在隐性关联等。基于模板的方法是关系抽取的传统方法，根据实体指称的画面上下文关系参照模板提取关系。基于机器学习的方法分为有监督学习和弱监督学习两类。有监督学习方法通过分类算法学习人工标注的实体指称关联样本进行模型训练，形成语义关系分类器用于关系提取。基于弱监督学习方法以距离监督为假设，对人工标注的部分图谱三元组样本进行学习以形成分类器，进而自动完成其他内容的关系抽取。Hasegawa等提出基于无监督技术的关系抽取，按实体特征进行全连通聚类，通过关系相似性确定实体关系的类型。视频、图片、语言等类型的情报信息直接进行关系抽取将是今后的发展方向。</code></pre><h4 id="4-利用知识图谱分析挖掘犯罪情报"><a href="#4-利用知识图谱分析挖掘犯罪情报" class="headerlink" title="4.利用知识图谱分析挖掘犯罪情报"></a>4.利用知识图谱分析挖掘犯罪情报</h4><ol><li><p>基于图谱的犯罪信息搜索传统的信息检索通过关键字匹配方式完成查找，未考虑关键字的语义和上下文关系，检索质量不高。基于知识图谱的实体检索同时考虑语义相似性和结构相似性，计算每个实体相关的三元组与用户查询之间的相关度，排序后得到候选实体。此外，知识图谱作为一种存在逻辑结构的有向连通图，可通过图模型进行建模检索，用检索对象的特征建立子图并构建图谱的图索引，通过子图筛选技术实现犯罪信息检索。当检索目标较复杂时可综合多个图谱进行搜索，基于图谱的问答技术用于提高搜索效果。基于词典-文法的语义解析方法通过分析问句，构建由节点、边和操作符组成的语义图，视其为图谱子图并映射到图谱中，通过图匹配完成检索。目前，基于知识图谱的简单问题检索基本成熟，但深层挖掘问题、大规模搜索和长尾问题等仍待研究。</p></li><li><p>基于图谱的案件推理知识图谱的结构化形式是其强于数据库的最大优势，支持信息推理，可用于情报的补齐、质检和挖掘，辅助研判。知识图谱推理着眼实体和关系，进行演绎推理和基于归纳的推理，由已有信息推断未知信息。归纳推理用于推理具体事实，利用逻辑规则获得某个事件的过程；演绎推理则着重提取知识图谱中的逻辑规则。演绎推理包括基于谓词逻辑的关系推理、基于概率逻辑的规则提取和基于随机游走的规则挖掘等。归纳推理包括基于置信规则推理的关系预测，基于路径的关系推理等。知识图谱推理技术可辅助事件规律挖掘、人员画像构建、特定群体发现、人物关系梳理等犯罪情报分析。</p></li></ol><h3 id="二、基于监控视频的视频图谱构建与挖掘"><a href="#二、基于监控视频的视频图谱构建与挖掘" class="headerlink" title="二、基于监控视频的视频图谱构建与挖掘"></a>二、基于监控视频的视频图谱构建与挖掘</h3><h4 id="1-视频图谱的设计与实现"><a href="#1-视频图谱的设计与实现" class="headerlink" title="1.视频图谱的设计与实现"></a>1.视频图谱的设计与实现</h4><pre><code>    知识图谱构建过程包含信息抽取、知识融合、知识加工。信息抽取从非结构化和半结构化数据中抽取实体、关系、实体属性，知识融合和知识加工对已有的信息进行语义消歧和知识推理等。视频图谱的构建与知识图谱类似，也是一个迭代的过程，采用自底向上的构建方式，为了实现摄像头下的行人人脸特征的快速提取，采用深度卷积神经网络，对提取后的特征进行聚类，就能得到每个行人唯一的身份。为了存储自动提取的信息，需要设计一个结合图数据库的存储方式，采用图数据库Neo4j进行实体、属性和关系数据的存储。节点作为实体，表示行人或者摄像头，边作为关系，表示行人之间、行人与摄像头之间的关系，属性作为实体的属性信息。</code></pre><h5 id="（1）图谱整体框架"><a href="#（1）图谱整体框架" class="headerlink" title="（1）图谱整体框架"></a>（1）图谱整体框架</h5><pre><code>    视频图谱包含三个基本要素：节点、边和属性，其中节点可以表示对象（如视频文档、视频中的人、车和物品），边表示对象间的关系，节点和边均可以有多个属性。以行人为例，行人可以经过多个摄像头，对行人出现的时间、行人的特征信息进行记录，可以挖掘行人之间的共现关系。视频图谱整体框架如下图所示。</code></pre><p><img src="https://img-blog.csdnimg.cn/20210303102413935.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyODE1ODA3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><pre><code>    视频图谱由多个视频对象组成，也可以用摄像头表示，表示一段监控视频或者一个摄像头。视频中出现的行人、车辆等信息通过自动化提取方法提取出来，并且极记录行人、车辆的相关信息，例如行人编号信息、出现的时间信息，作为行人的属性信息表示在图谱中。通过共现关系分析，找到图谱中具有共现关系的行人，也可以进而通过关系的连接，找出对应的团伙。</code></pre><h5 id="（2）图谱构建的实现"><a href="#（2）图谱构建的实现" class="headerlink" title="（2）图谱构建的实现"></a>（2）图谱构建的实现</h5><pre><code>    基于监控视频的视频图谱的构建总体流程如下图所示。总共分为以下几个模块：人脸检测及特征提取、人脸聚类、实体关系存储、共现关系发现、图谱展示。</code></pre><p>（1）人脸检测及特征提取模块包括：使用深度学习的方法检测摄像头视频流中的行人，提取行人的人脸特征等；</p><p>（2）人脸聚类模块包括：使用基于密度的DBSCAN算法将检测到的人脸聚成不同的类别，分配不同的cluster_id等；</p><p>（3）数据存储模块包括：使用图数据库Neo4j存储监控视频中出现行人实体的信息，以及和摄像头之间的出现关系等；</p><p>（4）共现关系发现模块包括：计算给定摄像头范围、给定时间阈值条件下的行人之间的共现关系等；</p><p>（5）图谱展示模块包括：使用前端展示框架展示视频图谱的样貌，提供交互式检索框等。<br><img src="https://img-blog.csdnimg.cn/20210303102449508.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyODE1ODA3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="（3）行人人脸特征提取和聚类"><a href="#（3）行人人脸特征提取和聚类" class="headerlink" title="（3）行人人脸特征提取和聚类"></a>（3）行人人脸特征提取和聚类</h5><pre><code>    视频图谱的自动化构建的基础是行人人脸检测和人脸特征提取，对于海量监控视频，将视频中出现的行人自动检测并提取出来，作为视频图谱的行人实体。如下图所示，从监控摄像头中读取视频流并提取视频的关键帧，只关注关键帧是为了避免不必要的检测，能够视频中减少人脸检测的次数，提高系统的运行效率，间隔几帧进行人脸检测即可。人脸检测和对齐使用MTCNN网络，网络的输入是视频帧，输出为包含人脸框和人脸关键点的图像。使用MTCNN网络检测人脸包括图像金字塔、P网络、R网络、O网络四个步骤。图像金字塔的作用是得到不同尺寸的输入图像，剩下的三个网络依次串联，上一个网络的输出作为下一个网络的输入。对于检测后的人脸使用残差网络模型提取人脸的深度特征，残差网络的输入为上一步得到的对齐后人脸图像，输出为高维人脸特征。最后对特征进行聚类，将同一个人的不同人脸样本聚到相同的类，聚类方法采用基于密度的DBSCAN方法，类内部的距离较为紧密，类之间距离较远，同一个类中的人脸表示同一个身份的行人的不同时间被抓拍到的快照，不同类表示不同身份的行人，对每一个聚类进行编号，用来表示监控视频中行人的身份。</code></pre><p><img src="https://img-blog.csdnimg.cn/20210303102504942.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyODE1ODA3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="（4）实体与关系的存储"><a href="#（4）实体与关系的存储" class="headerlink" title="（4）实体与关系的存储"></a>（4）实体与关系的存储</h5><pre><code>    节点储存，图数据库中节点表示实体，在视频图谱中，实体有行人、摄像头等。所以节点分为：行人节点和摄像头节点。基于Neo4j的标签规则，指定行人节点的标签为Person，摄像头节点的标签为Camera。标签是Neo4j数据库的分类信息，通过标签可以方便快速进行匹配。    关系存储，图数据库中关系表示联系，视频图谱中，实体之间的联系是关键信息。关系建立在两个已知节点的基础上，关系分为单向关系和双向关系。在视频图谱中，有多种关系，例如行人和摄像头的关系，为出现关系，可以指定为单向关系，开始节点为摄像头节点，结束节点为行人节点；摄像头之间的关系为连通关系，指定为双向关系。    属性存储，图数据库中不仅实体包含属性，关系也有属性信息。属性既存在于节点中，也存在于关系中。Person节点中可以存储行人出现的时间、行人的快照、行人的人脸特征等信息，Camera节点中可以存储摄像头的一些静态信息，例如摄像头的编号、位置描述、经纬度等信息；对于关系，以行人和摄像头之间的关系为例，一个关系对应于行人出现在摄像头下的一次情况，存储时间、快照等信息。</code></pre><p><img src="https://img-blog.csdnimg.cn/20210303102522854.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyODE1ODA3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="2-视频图谱的数据挖掘"><a href="#2-视频图谱的数据挖掘" class="headerlink" title="2.视频图谱的数据挖掘"></a>2.视频图谱的数据挖掘</h4><h5 id="（1）共现关系的发现"><a href="#（1）共现关系的发现" class="headerlink" title="（1）共现关系的发现"></a>（1）共现关系的发现</h5><pre><code>    在文献计量研究领域中，共同出现的特征项之间存在着某种关联，关联程度可以使用共现频次来评估。例如，通过分析一篇文章，要找到文章中两个人物之间的关系，一般认为，在同一篇文章中出现的两个人物的名字有一定的关联，统计全文出现的关联次数，可以构造任何两个人物之间的共现关系。视频图谱中，共现关系与上述描述类似，场景和实体有所不同，在多个实际场景中，一定范围的时间跨度内，不同行人被摄像头一起抓拍到，则认为他们之间有一定的联系。如下图所示，两人行人分别在时间上被相同的摄像头拍摄到，那么认为他们之间存在共现关系。</code></pre><p><img src="https://img-blog.csdnimg.cn/20210303102543421.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyODE1ODA3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="（2）共现关系的预测"><a href="#（2）共现关系的预测" class="headerlink" title="（2）共现关系的预测"></a>（2）共现关系的预测</h5><pre><code>    关联规则分析的目的是找出数据集之间各项之间的联系，常被称为购物篮分析。在监控视频图谱的场景中，如果根据大量的历史数据，分析出某个犯罪嫌疑人出现的情况下，其他犯罪同伙出现的概率，那么将发挥出视频图谱更深层次的作用，基于共现关系发现算法，进一步采用关联规则算法预测某一个行人出现的条件下，与之有关联的人出现的概率。关联规则分析的结果是规则的预测，规则是“如果…那么…”的形式，“如果”是条件，“那么”是结果。    关联规则分析首先被提出就是为了解决购物篮的问题，旨在找出大量商品购物之间的关联，后来被广泛应用与信息领域，而在如今的使用情境下，根据监控视频图谱的环境，使用关联规则的核心思路，找出适用于此环境的关联规则分析结果。Apriori算法作为关联规则分析的经典算法被广泛讨论，也是最早使用的关联规则算法；FP-Growth算法基于Apriori做了优化处理，通过构建一个FP-Tree来生成频繁项集，减少了磁盘的IO次数，提升算法的性能；当数据不断增长时，使用单机处理容易达到瓶颈，使用基于分布式的FP-Growth算法是理所当然的选择。</code></pre><h3 id="三、基于知识图谱的预测"><a href="#三、基于知识图谱的预测" class="headerlink" title="三、基于知识图谱的预测"></a>三、基于知识图谱的预测</h3><h4 id="案例一、城市交通拥堵区域预测研究"><a href="#案例一、城市交通拥堵区域预测研究" class="headerlink" title="案例一、城市交通拥堵区域预测研究"></a>案例一、城市交通拥堵区域预测研究</h4><pre><code>    智能交通系统是一种先进的应用程序，指将各种先进的技术如大数据，信息通信技术，电子控制技术等各种集成到整个运输管理系统中，旨在提供与不同交通方式和交通管理相关的创新服务。随着电子器件、大数据和人工智能的发展，通过智能化技术来缓解交通拥堵情况已经是交通管理的趋势，同时传感器技术的进步产生了更高精度且可实时获取的交通数据，为交通状况的分析与预测提供了海量的数据支持。因此，如何针对多源异构的交通大数据，探索更加先进的方法对研究城市交通拥堵预测具有重要意义。</code></pre><h5 id="交通拥堵预测研究现状"><a href="#交通拥堵预测研究现状" class="headerlink" title="交通拥堵预测研究现状"></a>交通拥堵预测研究现状</h5><pre><code>    Ryo提出了一种基于信息科学中的频繁模式挖掘算法，从交通传感器数据中列举交通拥堵模式的方法，来了解城市当前的交通拥堵情况。该方法改进了频繁模式挖掘算法从而有效地挖掘时空相关的拥堵模式并预测拥堵。    Li提出了一种自适应数据驱动的实时拥堵预测方法。该方法包括基于自适应K均值聚类的交通模式识别算法，二维速度预测模型和自适应阈值校准方法。在主成分分析之后，进行自适应K均值聚类算法以获得不同的流量模式。利用自适应阈值校准方法实现拥堵识别，然后根据不同的流量模式提出拥堵预测。OnievaTM提出了一个实验研究，将机器学习方法应用于预测道路的拥堵程度。该研究旨在找出相关结论以及产生包含一组规则的模型，同时考虑清晰和模糊变体。所使用的方法显示出良好的性能，模型能够准确指示出拥堵的程度。    Wan设计了一种基于深度学习理论的拥堵预测模型来预测交通拥堵，分析了不同迭代次数和学习率对模型预测精度的影响。文章在现有研究的基础上，提取了交通拥堵的影响因素，如交通流量，天气和光线，并构建状态矩阵来表示交通流的状态，提出了基于CNN预测的交通拥堵模型，使用状态矩阵作为输入变量。    在国内研究方面，姚智胜和邵春福运用状态空间模型将拥堵问题转化为多点时间序列预测，构建多维自回归模型，模型参数使用EM算法估计，将道路多点的交通状态作为研究对象，并利用卡尔曼滤波进一步预测系统状态，在快速路上6个采样点的真实数据进行验证，自回归模型预测效果比卡尔曼滤波单点预测方法更好。</code></pre><h5 id="城市知识图谱的意义"><a href="#城市知识图谱的意义" class="headerlink" title="城市知识图谱的意义"></a>城市知识图谱的意义</h5><pre><code>    如今，城市交通方面的应用通常依赖于手动特征工程，这可能导致一些隐特征被忽视。例如，通常需要为城市计算中的机器学习任务构建和组合一些复杂的特征。然而，城市交通应用的复杂性和交通数据的多源异构形式使得特征构建任务极具挑战性。此外，大多数基于学习(机器学习、深度学习)的方法不能对提供预测结果的解释。从城市中的传感器和社交媒体中获得的数据里包含数百种能够被人类理解的概念。大城市中的每个区域都包含一些隐藏和固有的知识(例如，人口统计，兴趣点等)。    当仅仅只提供与区域有关的少数城市知识时，人类就可以对该区域进行评估并得到令人满意的结果。与此相反的是，基于学习的方法例如机器学习或者深度学习通常需要数干个具有复杂特征工程的标记实例才能达到类似的效果。所以组合城市知识和基于深度学习的方法来共同解决某些城市应用问题例如城市交通拥堵预测问题。    知识图谱这种结构化知识表示方法已经在搜索引擎中发挥了重要作用，并逐渐延伸到电商和医疗领域，电商知识图谱用于提升个性化推荐效果，医疗知识图谱用于辅助医疗和智能问诊。浙江大学的马晓蕾等人首次将知识图谱应用于商铺选址和交通事故推理问题中。从历史经验、地理知识和常识中得到的城市知识图谱在实际应用中起着意想不到的作用。</code></pre><h5 id="城市知识图谱的构建"><a href="#城市知识图谱的构建" class="headerlink" title="城市知识图谱的构建"></a>城市知识图谱的构建</h5><pre><code>    主要有两种方法构建知识图谱:一个是自上而下的，另一个是自底而上的。自顶而下的方法意味着需要定义本体和模式，并将知识实例添加到知识库中。这种方法强调明确定义的领域本体来表示知识图谱中的实际实例，从其他知识资源中抽取知识实例。自底而上的知识图谱构造是一个迭代的过程，包括知识获取，知识融合，知识存储和提取等，往往是从互联网多源数据中获取并于已有的结构化数据相融合并提取有用的知识。</code></pre><h4 id="案例二、基于知识图谱的人员关系预测方法研究"><a href="#案例二、基于知识图谱的人员关系预测方法研究" class="headerlink" title="案例二、基于知识图谱的人员关系预测方法研究"></a>案例二、基于知识图谱的人员关系预测方法研究</h4><pre><code>    近年随着“人工智能”概念的再度活跃，除了“深度学习”这个炙手可热的名词以外，“知识图谱”无疑也是研究者、工业界心目中的又一颗“银弹”。简单地说，“知识图谱”就是以图形的方式来展现“实体”、实体“属性”，以及实体之间的“关系”。知识图谱的主要目标是用来描述真实世界中存在的各种实体和概念，以及它们之间的关联关系。    通过对海量数据的感知、认知，搭建完整的知识体系，在此基础上，阐述知识图谱进行关系预测的基本原理和基本方法，开展基于关系的知识推理和预测分析。以模拟真实世界的人活动关键要素为依据的，构建信息资源模型，将参与的自然人、人通过各种方式社交构成的社交关系及相关联的事件等关键要素，结合相应的算法模型，进行显性关系和隐藏关系的挖掘和预测，并对人员实体关系分析预测进行可视化展示。</code></pre><h5 id="知识图谱搭建流程"><a href="#知识图谱搭建流程" class="headerlink" title="知识图谱搭建流程"></a>知识图谱搭建流程</h5><pre><code>    搭建知识图谱需从多种信息源获取实体或概念，以及他们之间的关联关系。知识图谱构建是否完备关键在于知识抽取引擎的构建，知识抽取细分为实体、属性、关系、事实、事件、分类等识别与抽取。知识图谱的数据源是多源异构的数据体系，包括公安内部</code></pre><p>数据、其他部委数据、互联网数据等。知识抽取引擎首先需要融合汇聚来自多个来源的异构数据，其中包括数据准备层，实现非结构化数据的结构化标注和数据格式转换，完成多源异构数据的语义融合，汇聚管理异构数据，优化上层访问效率。</p><p>在数据平台层，知识抽取引擎主要进行数据采集和数据整合工作。数据采集工作主要内容包括以下几个方面:</p><ol><li><p>结构化数据智能抽取:智能化数据抽取是数据深度应用的前提，基于机器学习技术通过大规模自动化智能化对多源数据进行的采集、清洗、归类，并关联所有数据，形成统一数据视图给后续的智能化应用服务。针对RDB、Streaming、Crawler、CSV/Excel/TXT等数据源，支持传统数据转换和机器学习数据转换。</p></li><li><p>非结构化特征提取，使用机器学习等手段提取非结构化数据的特征作为标注;</p></li><li><p>数据格式转换，将不符合预定格式的数据转化为预定格式下的数据。</p></li></ol><p>数据整合工作主要内容包括以下几个方面:</p><ol><li><p>模式对应:实现在关系数据库模式层次和非结构化数据在概念层次的匹配对应;</p></li><li><p>实体链接:利用相似性计算、聚类划分等技术，实现在异构数据在实例层次对应;</p></li><li><p>冲突检测:在完成实例对应后，检测是否存在相同实体的相同属性值冲突;</p></li><li><p>冲突消除:利用机器学习、异常点判定、人工干预等手段消除检测到的冲突;</p></li><li><p>数据融汇:汇聚异构数据，优化上层访问效率。</p></li></ol><p>经知识抽取引擎进行数据采集和数据整合工作后，形成数据资源库，包括基础资源库、专题数据库、关联库和全文检索库。为关系预测综合研判提供所需的数据支撑。</p><pre><code>    在关系抽取层，针对图谱增强的知识化实体理解技术，开展开源辅助信息关联，支撑面向图谱的高效匹配和关联检索应用。实体关系抽取主要关注:实体对之间的关系的预测，实体对特定关系的挖掘，开放式实体关系的抽取。    在知识图谱构建层，包括知识构建、知识更新、知识融合。知识构建主要是基于以上流程将知识收集;知识更新主要解决知识的动态感知和更新问题，用以体现知识的变化对知识图谱中所存储知识的影响;知识融合主要是进行实体识别，即给定不同数据源中的实体，判断其是否指向同一个真实世界实体。知识融合过程中，要准确识别待合并知识与知识库中已有知识相重复或相矛盾的部分，并对冗余知识和矛盾知识采取适当的措施进行处理，以保证知识库中的知识是一致性，无冗余、无矛盾。</code></pre><h5 id="知识图谱关系预测的原理"><a href="#知识图谱关系预测的原理" class="headerlink" title="知识图谱关系预测的原理"></a>知识图谱关系预测的原理</h5><p>知识图谱关系预测根据是否和业务相关，主要分为基于规则的预测和基于算法的预测。</p><ol><li><p>基于规则的预测:主要是通过业务本体框架中的相关约束来做相关的推理预测，比如类别预测、属性预测等，通过关系的定义域和值域来推理预测。关系的定义域和值域是固定的，实例具有这种关系，则实例就是定义域或值域规定的类别。</p></li><li><p>基于算法的预测:基于算法的预测可以分为很多种，基于路径的建模、分布式表示学习、基于神经网络、混合推理等，但推理算法获得的结果具有不确定性，不一定等获得完全正确的关系，只是一种预测可能性。比如:通过观察到知识图谱中包含这样的一条路径“梅琳达·盖茨-配偶-比尔·盖茨-主席-微软-总部-西雅图”，推测出梅林达可能居住在西雅图。</p></li></ol><h5 id="知识图谱关系信息资源模型设计"><a href="#知识图谱关系信息资源模型设计" class="headerlink" title="知识图谱关系信息资源模型设计"></a>知识图谱关系信息资源模型设计</h5><pre><code>    基于知识图谱的关系预测的核心是建立符合业务的信息资源模型和算法。信息资源模型的设计是以模拟真实世界的人活动关键要素为依据的。参与的自然人(核心和边缘份子)通过各种社交构成的社交关系，人员个体在相关关键事件(如违法案件、应急突发事件)过程中，在长时空范围的系列活动、重点区域(如案件多发区、重点场所)等都是活动关系构成的几个关键要素，需要在构建模型时重点关注和研究，在业务模型的构建后采用一些图算法来开展关系分析和研判，从而能发现潜在的关系。    首先，在进行研判的过程中，通过对各类数据按照不同业务类别进行数据分析研判，形成不同主题域组织形式的数据模型库。随着研判的不断深入，公安知识库所产生的主题模型也将不断的扩展，在系统建设过程中，实现搭建自然人中心主题模型、社交为中心的主题模型、关键事件为中心的主题模型以及重点区域为中心的主题模型。    第二，基于综合图谱模式的匹配技术:在重要行为记录的事件、组织记录的模式检索中，借助基于关联子结构、子模式的匹配技术，可以构建频繁结构索引，剪枝-确认迭代操作等进行高效的综合匹配检索，以实现突破传统关键字技术的检索模式，支持基于复杂时间，行为轨迹，兴趣聚簇的检索任务，支撑多种上层分析研判应用的开展。</code></pre><h4 id="案例三、基于医学知识图谱的疾病诊断与健康预测模型研究"><a href="#案例三、基于医学知识图谱的疾病诊断与健康预测模型研究" class="headerlink" title="案例三、基于医学知识图谱的疾病诊断与健康预测模型研究"></a>案例三、基于医学知识图谱的疾病诊断与健康预测模型研究</h4><pre><code>    面向医学知识图谱的推理和预测模型是利用知识实现智能化医疗行为的两种重要技术手段，推理是通过演绎、归纳和类比等方式，对患者状态和情况得出认知结论，预测则是根据患者历史性数据作出合理化估计。它们的关联在于，预测是一种基于时间维度上的演化推理，二者本质上均是运用知识产生合乎逻辑的判定过程。在疾病诊断任务中，分类作为人类推理能力的重要体现，是衡量医疗智能化程度的关键所在。结合用户个性化信息，其研究意义分别体现在面向医护人员的辅助诊断、检查推荐、病历质检等应用场景，以及面向患者的健康信息推荐、过度检查筛查等医疗健康服务。    基于医学文本的知识图谱构建是解决医疗决策支持问题的物质基础。目前，知识图谱无论在学术界还是产业界都备受关注，已经在智能搜索、自动问答、决策支持等各个相关任务上得到了广泛应用，其优势主要归结于以下几点：</code></pre><ol><li>知识图谱是人工智能应用不可或缺的基础资源。知识图谱在语义搜索、问答系统、个性化推荐等互联网应用中占有重要地位，在智慧医疗、智慧司法等领域具有广阔的发展前景。</li><li>语义表达能力丰富，能够支持多种知识服务类任务。知识图谱源于语义网络，是一阶谓词逻辑的简化形式，通过定义概念、实例、属性以及关系类型，进一步丰富了对客观知识的描述能力。</li><li>描述形式统一，便于知识的集成与融合。知识图谱是知识构建体系和实例数据的统一表示框架，可通过术语对齐、结构匹配等操作对异构数据进行集成和融合，并为更复杂、更灵活的知识服务提供支持。</li><li>表示方法对人类和计算机友好，支持高效推理。推理是知识表示的重要目标，知识图谱以图结构为基础，在具备可解释性的同时，结合图论相关研究可以高效地应用于知识推理技术。</li></ol><h5 id="医学知识图谱构建"><a href="#医学知识图谱构建" class="headerlink" title="医学知识图谱构建"></a>医学知识图谱构建</h5><pre><code>    医学文本通指用于描述医学知识、存储健康数据和信息的结构化或非结构化文本，其中蕴含了医生在理论学习和医疗实践中丰富的常识性医学知识和经验性医学知识。    电子病历和医学书籍是两类最常见的医学文本，通常被作为医学知识的主要数据来源，针对这些半结构化或非结构化的文本数据，研究者们采用自动化抽取与人工编辑相结合的方式从中挖掘知识。鉴于知识之间的高度关联性和复杂性等特点，Google于2012年提出了一种基于网络结构的知识表示形式——知识图谱，其设计初衷是根据统一的表示框架描述现实世界中存在的实体以及实体之间的关系。相比于传统的关系型知识库，知识图谱具备较强的逻辑性、表示能力以及高效的存储和更新方式。随着人工智能技术在医疗领域的快速发展，以医疗本体Ontology）为基础原型衍生出许多具有代表性的医疗知识图谱，例如统一医学语言系统UMLS、本体医疗知识SNOMED-CT、IBM Watson Health等。此外，i2b2、N2C2、SemEval一些评测机构近年来也发布了多个与医学知识图谱构建相关的任务，包括实体识别、关系抽取、概念标准化等等，这些评测任务不仅为医学知识图谱构建指明了研究思路，而且提供了丰富的数据资源。    根据临床指南和电子病历中蕴含的知识形式，我们按照概念和关系的分类体系进行人工标注医学知识三元组。人工标注流程共分为三个阶段，首先是结合知识图谱的分类体系构建面向医学文本或特定医学知识库的标注规范初稿，在医师的指导下对现有的概念和关系进行合理性论证，对相似或歧义项给出明确的医学界定，同时提供相应的标注提示。之后进入训练标注人员并更新标注规范阶段，由于标注人员对于规范的理解不尽相同，即使是专业医生也会存在医学认知的差异。因此，我们每轮随机选取一定数量的未标注数据集同时分发给多名参与标注的人员，当标注完成后由所有标注人员一同讨论产生不一致的情况并最终达成统一。按照此种培训方式，经过多轮学习标注规范和标注人员对于医学知识的认识已经趋于成熟，当标注一致性连续三次处于较高水平后，我们认为可以进行医学知识的正式标注。最后，为达到较高的标注一致性，我们分配两组人员具有一定重复的医学文本进行正式标注，并阶段性随机抽样检查，出现冲突情况随时讨论，直至完成全部医学文本的标注工作。    经上述人工标注过程，我们初步构建了以三元组关系为结构单元的医学知识图谱，该图谱将常识知识和经验知识相结合，可以有效支持基于知识的推理模型的相关研究。</code></pre><h5 id="基于医学知识图谱的概率推理模型"><a href="#基于医学知识图谱的概率推理模型" class="headerlink" title="基于医学知识图谱的概率推理模型"></a>基于医学知识图谱的概率推理模型</h5><pre><code>    分类模型在过去一段时间被广泛应用于医疗领域的多项任务中，其中最为常见的是以症状作为模型的特征输入，对预设疾病进行诊断分类。决策树模拟人在诊断疾病中的判定逻辑，基于信息熵构造特征变量的树状结构，将整体分类过程分解为多个子任务逐步实现疾病诊断。然而该算法的不足在于对不一致性数据过度敏感，当训练数据集中存在矛盾时无法得到令人满意的拟合效果。支持向量机模型是另一类具有较强理论基础的分类模型，通过核函数将分类维度提升进而找到高维度下的最大支持向量面。虽然在多种医学任务中其预测准确</code></pre><p>率要优于决策树，但该模型过于依赖有效特征的选取。贝叶斯网络是以贝叶斯理论为基础的概率图模型，以图的形式描述变量之间的依赖关系，在早期的临床决策系统中发挥了重要作用。近年来，随着大数据时代的到来，深度学习技术得到了快速发展，又涌现出以神经网络、模糊逻辑、遗传算法为代表的一大批诊疗推理模型。</p><pre><code>    人类产生智能的根本原因是知识的不断学习，当知识量到达一定程度会自然地涌现出较高的认知水平。面向分类任务的深度学习相比于面向知识的概率逻辑推理模型，前者是将符号化知识抽象为低维空间向量后，采取反向传播机制训练神经元表示和网络权重，以达到分类和推理的任务目标。而前者更多依赖于符号化知识，在已知相关先验和当前条件下，运用统计学原理可以近似计算特定事件的发生概率。更重要的是，不同于深度学习中知识向量的高度抽象化，概率逻辑模型的推理方式更贴近人类认知，有如贝叶斯理论和马尔科夫理论的推理过程具有显著的可解释性。其中，早期的代表性研究包括基于人类总结性规则的专家系统、基于一阶逻辑知识的马尔科夫网、概率软逻辑等等，不过上述模型在适用范围上均存在着局限性，例如基于逻辑知识的推理模型仅能处理二元变量。而在医疗领域，大多数医疗检查、症状描述均表示为多元数值形式。为解决上述问题，马尔科夫逻辑网的衍生算法——混合马尔科夫逻辑网通过变量近似和抽样评估的统计策略将布尔类型和数值型变量融入概率逻辑框架。    传统的马尔科夫网无法应对多元变量的推理问题，针对医疗领域的数据特点，充分结合了医学知识图谱的网络结构与概率图模型的推理能力，提出了面向知识图谱的精确推理和参数学习统一框架。在该推理框架中引入波尔茨曼机能量函数对马尔科夫网团势能函数进行重定义，使标准化的数值型变量直接参与到推理计算中，解决了传统概率图模型无法处理多元变量的问题。实验结果表明，在基于“疾病-症状”知识网络和“疾病-检查”知识网络的多疾病诊断任务中，该推理框架不仅可以应对以不同程度症状为证据的多元离散型变量，而且可以处理以数值型检查结果为代表的连续型变量，并取得了最佳的疾病诊断效果。</code></pre><h5 id="基于级联失效理论的健康预测模型"><a href="#基于级联失效理论的健康预测模型" class="headerlink" title="基于级联失效理论的健康预测模型"></a>基于级联失效理论的健康预测模型</h5><pre><code>    级联失效是描述复杂网络动态演变过程的一种理论，由初始网络中少数节点失效而引发的蝴蝶效应，最终导致相当一部分节点甚至整个网络的崩溃。级联行为常见于各类复杂系统中，例如电力网络、金融市场、交通网络，其潜在的巨大风险推动着研究者们投入大量精力探究其本质，进而提出规避风险的预防措施以及降低灾难性后果的新举措。    网络医学作为结合系统生物学和网络科学的一类新型学科，旨在提出可以用来剖析人类所有疾病成因的研究思路与策略，对于理解异常体征和疾病之间的关系至关重要。其主要观点认为人体本身是一个高度复杂化的生理系统，生理状态之间存在相互影响、制约、促进、激发等一系列作用关系，例如由糖尿病诱发的众多并发症、由癌症引发的器官衰竭以及由艾滋病病毒导致的免疫系统崩溃。因此，探索基于人体功能性系统的动态演变行为是洞悉疾病发展规律、挖掘异常体征与疾病关联性、预测患病风险的根本性研究，为早发现、早预防、早治疗的良性就医方式提供坚实的理论基础。    结合上述级联失效的动态演绎过程和体征之间的客观作用机制，设想通过医学知识网络来刻画人体系统，一旦某些生理节点出现异常，其负面影响必将通过节点之间的诱发关系传递到邻居节点，并使更多节点出现异常甚至失效（所谓失效是指体征指标超出正常值范围或表现出某种疾病），经有限次扩散该影响可能会波及整个网络，进而导致大面积节点的失效。受此启发，研究以疾病和体征组建的医学知识网络为结构，采用实验手段探索发生在该医学网络中的级联行为。通过量化局部节点的客观作用关系，在传播动力学的驱使下，试图模拟网络结构及节点状态自主更迭的动态演变过程，最终在给定患者初始体征的情况下有效预测其未来可能出现的异常体征或疾病。同时，对级联过程起到关键推动力的医学节点进行挖掘，可以有针对性的提供保护策略和治疗手段为疾病预防和疾病早期发现提供重要的理论依据。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;知识图谱内容调研&quot;&gt;&lt;a href=&quot;#知识图谱内容调研&quot; class=&quot;headerlink&quot; title=&quot;知识图谱内容调研&quot;&gt;&lt;/a&gt;知识图谱内容调研&lt;/h1&gt;&lt;h2 id=&quot;是什么&quot;&gt;&lt;a href=&quot;#是什么&quot; class=&quot;h
      
    
    </summary>
    
    
      <category term="AI" scheme="http://yoursite.com/categories/AI/"/>
    
    
      <category term="知识图谱" scheme="http://yoursite.com/tags/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记——如何有效阅读一本书</title>
    <link href="http://yoursite.com/2021/02/15/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%A6%82%E4%BD%95%E6%9C%89%E6%95%88%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6/"/>
    <id>http://yoursite.com/2021/02/15/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%A6%82%E4%BD%95%E6%9C%89%E6%95%88%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6/</id>
    <published>2021-02-15T10:28:29.000Z</published>
    <updated>2021-08-08T14:47:09.488Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://images-cn.ssl-images-amazon.cn/images/I/414i5iEux4L.jpg" align="center"></p><blockquote><p>作者: <a href="https://book.douban.com/author/1101026/" target="_blank" rel="noopener">[日本] 奥野宣之</a><br>出版社: 江西人民出版社<br>出品方: <a href="https://book.douban.com/series/39051?brand=1" target="_blank" rel="noopener">后浪</a><br>副标题: 超实用笔记读书法<br>原作名: 読書は1冊のノートにまとめなさい<br>译者: <a href="https://book.douban.com/search/张晶晶" target="_blank" rel="noopener">张晶晶</a><br>出版年: 2016-6<br>ISBN: 9787210082972</p></blockquote><div class="note info"><p>210215</p></div><blockquote class="blockquote-center"><p>读书时获得的感想正是原创思考的源泉。</p></blockquote><blockquote class="blockquote-center"><p>对比书评和自己的感想，可以让后者变得不那么绝对化。</p></blockquote><blockquote class="blockquote-center"><p>亚瑟·叔本华在《论读书》中写道：“如果你觉得读书就是为了模仿别人的想法，那么这是思想上的懒惰。请丢开书本自己思考。”</p></blockquote><blockquote class="blockquote-center"><p>积极输出促进思想内化，即使掌握再多信息，如果不去积极输出，也无法形成知识体系。</p></blockquote><blockquote class="blockquote-center"><p>漫无目的地与人说话时，虽然说的内容是支离破碎的，但在阐述的过程中，语言会不断得到整理，思维也会逐渐清晰。</p></blockquote><blockquote class="blockquote-center"><p>浪费时间不算什么，但请不要浪费人生。</p></blockquote><blockquote class="blockquote-center"><p>创意源自既有信息重组</p></blockquote><blockquote class="blockquote-center"><p>经得起时光洗礼的书一定有流芳百世的价值。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://images-cn.ssl-images-amazon.cn/images/I/414i5iEux4L.jpg&quot; align=&quot;center&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;作者: &lt;a href=&quot;https://book.
      
    
    </summary>
    
    
      <category term="Reading" scheme="http://yoursite.com/categories/Reading/"/>
    
    
      <category term="Reading" scheme="http://yoursite.com/tags/Reading/"/>
    
  </entry>
  
  <entry>
    <title>基于Q-Learning 的FlappyBird AI</title>
    <link href="http://yoursite.com/2020/12/27/%E5%9F%BA%E4%BA%8EQ-Learning%20%E7%9A%84FlappyBird%20AI/"/>
    <id>http://yoursite.com/2020/12/27/%E5%9F%BA%E4%BA%8EQ-Learning%20%E7%9A%84FlappyBird%20AI/</id>
    <published>2020-12-26T18:41:28.000Z</published>
    <updated>2020-12-26T19:59:51.823Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基于Q-Learning-的FlappyBird-AI"><a href="#基于Q-Learning-的FlappyBird-AI" class="headerlink" title="基于Q-Learning 的FlappyBird AI"></a>基于Q-Learning 的FlappyBird AI</h1><p>在<a href="https://github.com/willz/birdbot" target="_blank" rel="noopener">birdbot</a>实现的FlappyBird基础上训练AI，这个FlappyBird的实现对游戏进行了简单的封装，可以很方便得到游戏的状态来辅助算法实现。同时可以显示游戏界面方便调试，能够看到算法实现的效果。也可以选择关闭游戏界面以及声音，这样游戏仍然能正常运行，一般用于训练阶段，可以减少CPU的占用</p><p>实现参考的是SarvagyaVaish的<a href="http://sarvagyavaish.github.io/FlappyBirdRL/" target="_blank" rel="noopener">Flappy Bird RL</a></p><h2 id="Q-Learning"><a href="#Q-Learning" class="headerlink" title="Q-Learning"></a>Q-Learning</h2><p>Q-Learning是强化学习算法中value-based的算法</p><p>Q即为Q（s,a）就是在某一时刻的 s 状态下(s∈S)，采取 动作a (a∈A)动作能够获得收益的期望，环境会根据agent的动作反馈相应的回报reward，所以算法的主要思想就是将State与Action构建成一张Q-table来存储Q值，然后根据Q值来选取能够获得最大的收益的动作</p><div class="table-container"><table><thead><tr><th>Q-Table</th><th>a1</th><th>a2</th></tr></thead><tbody><tr><td>s1</td><td>q(s1,a1)</td><td>q(s1,a2)</td></tr><tr><td>s2</td><td>q(s2,a1)</td><td>q(s2,a2)</td></tr><tr><td>s3</td><td>q(s3,a1)</td><td>q(s3,a2)</td></tr></tbody></table></div><h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><p><img src="https://img-blog.csdnimg.cn/2020122703554185.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyODE1ODA3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>在更新的过程中，引入了学习速率alpha，控制先前的Q值和新的Q值之间有多少差异被保留</p><p>γ为折扣因子，0&lt;= γ&lt;1，γ=0表示立即回报，γ趋于1表示将来回报，γ决定时间的远近对回报的影响程度</p><p>详细的Q-Learning过程可以参考下面这篇</p><p><a href="https://blog.csdn.net/itplus/article/details/9361915" target="_blank" rel="noopener">A Painless Q-learning Tutorial (一个 Q-learning 算法的简明教程)</a></p><h2 id="FlappyBird中应用"><a href="#FlappyBird中应用" class="headerlink" title="FlappyBird中应用"></a>FlappyBird中应用</h2><h3 id="状态空间"><a href="#状态空间" class="headerlink" title="状态空间"></a>状态空间</h3><ul><li>从下方管子开始算起的垂直距离</li><li>从下一对管子算起的水平距离</li><li>鸟：死或生</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/213ef34c9129af22c9bb1af354c6569f.png" alt="img"></p><h3 id="动作"><a href="#动作" class="headerlink" title="动作"></a>动作</h3><p>每一个状态，有两个可能的动作</p><ul><li>点击一下</li><li>啥也不干</li></ul><h3 id="奖励"><a href="#奖励" class="headerlink" title="奖励"></a>奖励</h3><p>奖励的机制完全基于鸟是否存活</p><ul><li><strong>+1</strong>，如果小鸟还活着</li><li><strong>-1000</strong>，如果小鸟死了</li></ul><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>伪代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">初始化 Q = &#123;&#125;;</span><br><span class="line">while Q 未收敛：</span><br><span class="line">    初始化小鸟的位置S，开始新一轮游戏</span><br><span class="line">    while S != 死亡状态：</span><br><span class="line">        使用策略π，获得动作a=π(S) </span><br><span class="line">        使用动作a进行游戏，获得小鸟的新位置S&apos;,与奖励R(S,a)</span><br><span class="line">        Q[S,A] ← (1-α)*Q[S,A] + α*(R(S,a) + γ* max Q[S&apos;,a]) // 更新Q</span><br><span class="line">        S ← S&apos;</span><br></pre></td></tr></table></figure><ol><li><p>观察Flappy Bird处于什么状态，并执行最大化预期奖励的行动。然后继续运行游戏，接着获得下一个状态s’</p></li><li><p>观察新的状态s’和与之相关的奖励：+1或者-1000</p></li><li><p>根据Q Learning规则更新Q阵列</p><p>Q[s,a] ← Q[s,a] + α (r + γ*V(s’) - Q[s,a])</p></li><li><p>设定当前状态为s’，然后重新来过</p></li></ol><p><img src="https://img-blog.csdnimg.cn/20201227035602587.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyODE1ODA3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pyglet</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> atexit</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> pybird.game <span class="keyword">import</span> Game</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bot</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, game)</span>:</span></span><br><span class="line">        self.game = game</span><br><span class="line">        <span class="comment"># constants</span></span><br><span class="line">        self.WINDOW_HEIGHT = Game.WINDOW_HEIGHT</span><br><span class="line">        self.PIPE_WIDTH = Game.PIPE_WIDTH</span><br><span class="line">        <span class="comment"># this flag is used to make sure at most one tap during</span></span><br><span class="line">        <span class="comment"># every call of run()</span></span><br><span class="line">        self.tapped = <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        self.game.play()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># variables for plan</span></span><br><span class="line">        self.Q = &#123;&#125;</span><br><span class="line">        self.alpha = <span class="number">0.7</span></span><br><span class="line">        self.explore = <span class="number">100</span></span><br><span class="line">        self.pre_s = (<span class="number">9999</span>, <span class="number">9999</span>)</span><br><span class="line">        self.pre_a = <span class="string">'do_nothing'</span></span><br><span class="line"></span><br><span class="line">        self.absolute_path = os.path.split(os.path.realpath(__file__))[<span class="number">0</span>]</span><br><span class="line">        self.memo = self.absolute_path + <span class="string">'/memo'</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> os.path.isfile(self.memo):</span><br><span class="line">            _dict = pickle.load(open(self.memo))</span><br><span class="line">            self.Q = _dict[<span class="string">"Q"</span>]</span><br><span class="line">            self.game.record.iters = _dict.get(<span class="string">"iters"</span>, <span class="number">0</span>)</span><br><span class="line">            self.game.record.best_iter = _dict.get(<span class="string">"best_iter"</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">do_at_exit</span><span class="params">()</span>:</span></span><br><span class="line">            _dict = &#123;<span class="string">"Q"</span>: self.Q,</span><br><span class="line">                     <span class="string">"iters"</span>: self.game.record.iters,</span><br><span class="line">                     <span class="string">"best_iter"</span>: self.game.record.best_iter&#125;</span><br><span class="line">            pickle.dump(_dict, open(self.memo, <span class="string">'wb'</span>))</span><br><span class="line"></span><br><span class="line">        atexit.register(do_at_exit)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># this method is auto called every 0.05s by the pyglet</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.game.state == <span class="string">'PLAY'</span>:</span><br><span class="line">            self.tapped = <span class="literal">False</span></span><br><span class="line">            <span class="comment"># call plan() to execute your plan</span></span><br><span class="line">            self.plan(self.get_state())</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            state = self.get_state()</span><br><span class="line">            bird_state = list(state[<span class="string">'bird'</span>])</span><br><span class="line">            bird_state[<span class="number">2</span>] = <span class="string">'dead'</span></span><br><span class="line">            state[<span class="string">'bird'</span>] = bird_state</span><br><span class="line">            <span class="comment"># do NOT allow tap</span></span><br><span class="line">            self.tapped = <span class="literal">True</span></span><br><span class="line">            self.plan(state)</span><br><span class="line">            <span class="comment"># restart game</span></span><br><span class="line">            <span class="keyword">print</span> <span class="string">'iters:'</span>,self.game.record.iters,<span class="string">' score:'</span>, self.game.record.get(), <span class="string">'best: '</span>, self.game.record.best_score</span><br><span class="line">            self.game.record.inc_iters()</span><br><span class="line">            self.game.restart()</span><br><span class="line">            self.game.play()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># get the state that robot needed</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_state</span><span class="params">(self)</span>:</span></span><br><span class="line">        state = &#123;&#125;</span><br><span class="line">        <span class="comment"># bird's position and status(dead or alive)</span></span><br><span class="line">        state[<span class="string">'bird'</span>] = (int(round(self.game.bird.x)), \</span><br><span class="line">                int(round(self.game.bird.y)), <span class="string">'alive'</span>)</span><br><span class="line">        state[<span class="string">'pipes'</span>] = []</span><br><span class="line">        <span class="comment"># pipes' position</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(self.game.pipes), <span class="number">2</span>):</span><br><span class="line">            p = self.game.pipes[i]</span><br><span class="line">            <span class="keyword">if</span> p.x &lt; Game.WINDOW_WIDTH:</span><br><span class="line">                <span class="comment"># this pair of pipes shows on screen</span></span><br><span class="line">                x = int(round(p.x))</span><br><span class="line">                y = int(round(p.y))</span><br><span class="line">                state[<span class="string">'pipes'</span>].append((x, y))</span><br><span class="line">                state[<span class="string">'pipes'</span>].append((x, y - Game.PIPE_HEIGHT_INTERVAL))</span><br><span class="line">        <span class="keyword">return</span> state</span><br><span class="line"></span><br><span class="line">    <span class="comment"># simulate the click action, bird will fly higher when tapped</span></span><br><span class="line">    <span class="comment"># It can be called only once every time slice(every execution cycle of plan())</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tap</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.tapped:</span><br><span class="line">            self.game.bird.jump()</span><br><span class="line">            self.tapped = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># That's where the robot actually works</span></span><br><span class="line">    <span class="comment"># NOTE Put your code here</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">plan</span><span class="params">(self, state)</span>:</span></span><br><span class="line">        x = state[<span class="string">'bird'</span>][<span class="number">0</span>]</span><br><span class="line">        y = state[<span class="string">'bird'</span>][<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> len(state[<span class="string">'pipes'</span>]) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> y &lt; self.WINDOW_HEIGHT / <span class="number">2</span>:</span><br><span class="line">                self.tap()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        h, v = <span class="number">9999</span>, <span class="number">9999</span></span><br><span class="line">        reward = <span class="number">-1000</span> <span class="keyword">if</span> state[<span class="string">'bird'</span>][<span class="number">2</span>] == <span class="string">'dead'</span> <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(state[<span class="string">'pipes'</span>]), <span class="number">2</span>):</span><br><span class="line">            p = state[<span class="string">'pipes'</span>][i]</span><br><span class="line">            <span class="keyword">if</span> x &lt;= p[<span class="number">0</span>] + self.PIPE_WIDTH:</span><br><span class="line">                h = p[<span class="number">0</span>] + self.PIPE_WIDTH - x</span><br><span class="line">                v = p[<span class="number">1</span>] - y</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        scale = <span class="number">10</span></span><br><span class="line">        h /= scale</span><br><span class="line">        v /= scale</span><br><span class="line">        self.Q.setdefault((h, v), &#123;<span class="string">'tap'</span>: <span class="number">0</span>, <span class="string">'do_nothing'</span>: <span class="number">0</span>&#125;)</span><br><span class="line">        self.Q.setdefault(self.pre_s, &#123;<span class="string">'tap'</span>: <span class="number">0</span>, <span class="string">'do_nothing'</span>: <span class="number">0</span>&#125;)</span><br><span class="line">        tap_v = self.Q[(h, v)][<span class="string">'tap'</span>]</span><br><span class="line">        nothing_v = self.Q[(h, v)][<span class="string">'do_nothing'</span>]</span><br><span class="line">        self.Q[self.pre_s][self.pre_a] += self.alpha * (reward + max(tap_v, nothing_v) - self.Q[self.pre_s][self.pre_a])</span><br><span class="line">        self.pre_s = (h, v)</span><br><span class="line">        <span class="keyword">if</span> random.randint(<span class="number">0</span>, self.explore) &gt; <span class="number">100</span>:</span><br><span class="line">            self.pre_a = <span class="string">"do_nothing"</span> <span class="keyword">if</span> random.randint(<span class="number">0</span>, <span class="number">1</span>) <span class="keyword">else</span> <span class="string">"tap"</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            tap_v = self.Q[self.pre_s][<span class="string">'tap'</span>]</span><br><span class="line">            nothing_v = self.Q[self.pre_s][<span class="string">'do_nothing'</span>]</span><br><span class="line">            self.pre_a = <span class="string">"do_nothing"</span> <span class="keyword">if</span> tap_v &lt;= nothing_v <span class="keyword">else</span> <span class="string">"tap"</span></span><br><span class="line">        <span class="keyword">if</span> self.pre_a == <span class="string">'tap'</span>:</span><br><span class="line">            self.tap()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">pass</span>  </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    show_window = <span class="literal">True</span></span><br><span class="line">    enable_sound = <span class="literal">False</span></span><br><span class="line">    game = Game()</span><br><span class="line">    game.set_sound(enable_sound)</span><br><span class="line">    bot = Bot(game)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(dt)</span>:</span></span><br><span class="line">        game.update(dt)</span><br><span class="line">        bot.run()</span><br><span class="line">    pyglet.clock.schedule_interval(update, Game.TIME_INTERVAL)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> show_window:</span><br><span class="line">        window = pyglet.window.Window(Game.WINDOW_WIDTH, Game.WINDOW_HEIGHT, vsync = <span class="literal">False</span>)</span><br><span class="line"><span class="meta">        @window.event</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">on_draw</span><span class="params">()</span>:</span></span><br><span class="line">            window.clear()</span><br><span class="line">            game.draw()</span><br><span class="line">        pyglet.app.run()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        pyglet.app.run()</span><br></pre></td></tr></table></figure><p>全部代码见<a href="https://github.com/BENULL/FlappyBirdBot" target="_blank" rel="noopener">github仓库</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://sarvagyavaish.github.io/FlappyBirdRL/" target="_blank" rel="noopener">Flappy Bird RL</a></li><li><a href="https://www.zhihu.com/question/26408259/answer/123230350" target="_blank" rel="noopener">如何用简单例子讲解 Q - learning 的具体过程？ - 牛阿的回答 - 知乎</a></li><li><a href="https://blog.csdn.net/qq_30615903/article/details/80739243" target="_blank" rel="noopener">Q-Learning算法详解</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基于Q-Learning-的FlappyBird-AI&quot;&gt;&lt;a href=&quot;#基于Q-Learning-的FlappyBird-AI&quot; class=&quot;headerlink&quot; title=&quot;基于Q-Learning 的FlappyBird AI&quot;&gt;&lt;/a&gt;基于Q-L
      
    
    </summary>
    
    
      <category term="AI" scheme="http://yoursite.com/categories/AI/"/>
    
    
      <category term="强化学习" scheme="http://yoursite.com/tags/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Q-Learning" scheme="http://yoursite.com/tags/Q-Learning/"/>
    
  </entry>
  
  <entry>
    <title>强化学习简介</title>
    <link href="http://yoursite.com/2020/12/27/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2020/12/27/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-12-26T18:41:28.000Z</published>
    <updated>2020-12-26T18:43:52.594Z</updated>
    
    <content type="html"><![CDATA[<h1 id="强化学习简介"><a href="#强化学习简介" class="headerlink" title="强化学习简介"></a>强化学习简介</h1><p>强化学习(Reinforcement Learning，RL)是机器学习中的一个领域，是学习做什么（即如何把当前的情景映射成动作）才能使得数值化的收益最大化,学习者不会被告知应该采取什么动作，而是必须自己通过尝试去发现哪些动作会产生最丰厚的收益</p><p>强化学习同机器学习领域中的<strong>有监督学习</strong>和<strong>无监督学习</strong>不同，有监督学习是从外部监督者提供的带标注训练集中进行学习（任务驱动型），无监督学习是一个典型的寻找未标注数据中隐含结构的过程（数据驱动型)</p><p>强化学习是与两者并列的第三种机器学习范式，强化学习带来了一个独有的挑战——<strong>探索</strong>与<strong>利用</strong>之间的折中权衡，智能体必须利用已有的经验来获取收益，同时也要进行探索，使得未来可以获得更好的动作选择空间（即从错误中学习）</p><p><img src="https://img-blog.csdnimg.cn/img_convert/1668acdd0c064f8332bbdcc02b5714bc.png" alt="img"></p><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><p>强化学习的主要角色是 <strong>智能体</strong> 和 <strong>环境</strong>,环境是智能体存在和互动的世界。智能体在每一步的交互中，都会获得对于所处环境状态的观察（有可能只是一部分），然后决定下一步要执行的动作。环境会因为智能体对它的动作而改变，也可能自己改变。</p><p>智能体也会从环境中感知到 <strong>奖励</strong> 信号，一个表明当前状态好坏的数字。智能体的目标是最大化累计奖励，也就是<strong>回报</strong>。强化学习就是智能体通过学习来完成目标的方法。<br><img src="https://img-blog.csdnimg.cn/20201227022859486.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyODE1ODA3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="马尔可夫决策过程-MDP"><a href="#马尔可夫决策过程-MDP" class="headerlink" title="马尔可夫决策过程(MDP)"></a><strong>马尔可夫决策过程(MDP)</strong></h3><blockquote><p>MDP 简单说就是一个智能体（Agent）采取行动（Action）从而改变自己的状态（State）获得奖励（Reward）与环境（Environment）发生交互的循环过程，MDP 的策略完全取决于当前状态（Only present matters），这也是它马尔可夫性质的体现</p></blockquote><p>强化学习任务通常用<strong>马尔可夫决策过程</strong> (Markov Decision Process, MDP)来描述，即</p><p>机器处于环境 <script type="math/tex">E</script> 中, 状态空间为 <script type="math/tex">X,</script> 其中每个状态 <script type="math/tex">x \in X</script> 是机器感知到的环境的描述</p><p>机器能采取的动作构成了动作空间 <script type="math/tex">A</script> ; 若某个动作 <script type="math/tex">a \in A</script> 作用在当前状态 <script type="math/tex">x</script> 上, 则潜在的转移函数 <script type="math/tex">P</script> 将使得环境从当前状态按某种概率转移到另一个状态; 在转移到另一个状态的同时, 环境会根据潜在的“奖赏” (reward)函数 <script type="math/tex">R</script> 反馈给机器一个奖赏</p><p>综合起来, 强化学习任务对应了四元组 <script type="math/tex">E=\langle X, A, P, R\rangle,</script> 其中 <script type="math/tex">P: X \times A \times X \mapsto \mathbb{R}</script> 指定了状态转移概率, <script type="math/tex">R: X \times A \times X \mapsto \mathbb{R}</script> 指定了奖赏; 在有的应用中, 奖赏函数可能仅与状态转移有关, 即 <script type="math/tex">R: X \times X \mapsto \mathbb{R} .</script></p><h2 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h2><p>机器要做的是通过在环境中不断地尝试而学得一个“策略” (policy) <script type="math/tex">\pi,</script> 根据这个策略, 在状态 <script type="math/tex">x</script> 下就能得知要执行的动作 <script type="math/tex">a=\pi(x)</script> </p><p>策略有两种表示方法:</p><p>一种是将策略表示为函数 <script type="math/tex">\pi: X \mapsto A,</script> 确定性策略常用这种表示</p><p>另一种是概率表示 <script type="math/tex">\pi: X \times A \mapsto \mathbb{R},</script> 随机性策略常用这种表示</p><p>其中 <script type="math/tex">\pi(x, a)</script> 为状态 <script type="math/tex">x</script> 下选择动作 <script type="math/tex">a</script> 的概率, 这里必须有 <script type="math/tex">\sum_{a} \pi(x, a)=1</script></p><h3 id="确定性策略"><a href="#确定性策略" class="headerlink" title="确定性策略"></a>确定性策略</h3><p>确定性策略，在相同的状态下，其输出的动作是确定的</p><p><strong>优缺点</strong></p><ul><li>能够利用确定性梯度优化策略，所以不需要太多的采样数据，计算效率也很快</li><li>由于每次面对同一状态其输出的动作是唯一的，无法讨论一些其它动作的效果，不具有自学习的能力</li></ul><h3 id="随机性策略"><a href="#随机性策略" class="headerlink" title="随机性策略"></a>随机性策略</h3><p>对于随机策略，对于相同的状态，其输出的状态并不唯一，而是满足一定的概率分布，从而导致即使是处在相同的状态，也可能输出不同的动作</p><p><strong>优缺点</strong></p><ul><li>随机策略将探索和改进集成到一个策略中</li><li>需要采样的数据量较大，学习比较慢</li></ul><h2 id="奖励"><a href="#奖励" class="headerlink" title="奖励"></a>奖励</h2><p>强化学习中，奖励函数<script type="math/tex">R</script>非常重要,它由当前状态、已经执行的行动和下一步的状态共同决定</p><script type="math/tex; mode=display">r_{t}=R\left(s_{t}, a_{t}, s_{t+1}\right)</script><p>长期累积奖励有多种计算方式</p><p>其中<script type="math/tex">T</script>步累计奖赏，指的是在一个固定窗口步数<script type="math/tex">T</script>内获得的累计奖励</p><script type="math/tex; mode=display">R(\tau)=\sum_{t=0}^{T} r_{t}</script><p>另一种叫做<script type="math/tex">\gamma</script>折扣奖励，指的是智能体获得的全部奖励之和，但是奖励会因为获得的时间不同而衰减。这个公式包含衰减率<script type="math/tex">\gamma \in(0,1)</script>：</p><script type="math/tex; mode=display">R(\tau)=\sum_{t=0}^{\infty} \gamma^{t} r_{t}</script><p>这里为什么要加上一个衰减率呢？为什么不直接把所有的奖励加在一起？可以从两个角度来解释： 直观上讲，现在的奖励比外来的奖励要好，所以未来的奖励会衰减；数学角度上，无限多个奖励的和很可能 不收敛，有了衰减率和适当的约束条件，数值才会收敛</p><h2 id="探索与利用"><a href="#探索与利用" class="headerlink" title="探索与利用"></a>探索与利用</h2><blockquote><p>所谓探索：是指做你以前从来没有做过的事情，以期望获得更高的回报</p><p>所谓利用：是指做你当前知道的能产生最大回报的事情</p></blockquote><h3 id="多臂赌博机问题"><a href="#多臂赌博机问题" class="headerlink" title="多臂赌博机问题"></a>多臂赌博机问题</h3><p>单步强化学习任务对应了一个理论模型, 即“ <script type="math/tex">K</script> -摇臂赌博机” ， <script type="math/tex">K</script> -摇臂赌博机有 <script type="math/tex">K</script> 个摇臂, 赌徒在投入一个硬币后可选择按下其中一个摇臂, 每个摇臂以一定的概率吐出硬币, 但这个概率赌徒并不知道。赌徒的目标是通过一定的策略最大化自己的奖赏, 即获得最多的硬币</p><p>仅探索(exploration only): 将所有的尝试机会平均分配给每个摇臂(即轮流按下每个摇臂)，最后以每个摇臂各自的平均吐币概率作为其奖赏期望的近似估计</p><p>仅利用(exploitation-only): 按下目前最优的(即到目前为止平均奖赏最大的)的摇臂，若有多个摇臂同为最优, 则从中随机选取一个.<br><img src="https://img-blog.csdnimg.cn/20201227023447177.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyODE1ODA3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>显然，“仅探索”法能很好地估计每个摇臂的奖赏, 却会失去很多选择最优摇臂的机会;“仅利用”法则相反, 它没有很好地估计摇臂期望奖赏, 很可能经常 选不到最优摇臂. 因此, 这两种方法都难以使最终的累积奖赏最大化.<br>事实上，探索和利用这两者是矛盾的, 因为尝试次数(即总投币数)有限, 加强了一方则会自然削弱另一方, 这就是强化学习所面临的“探索-利用困境” (Exploration Exploitation dilemma)</p><p> 显然, 欲累积奖赏最大, 则必须在探索与利用之间达成较好的折中</p><h3 id="epsilon-贪心法"><a href="#epsilon-贪心法" class="headerlink" title="\epsilon -贪心法"></a><script type="math/tex">\epsilon</script> -贪心法</h3><p><script type="math/tex">\epsilon</script> -贪心法基于一个概率来对探索和利用进行折中: 每次尝试时, 以 <script type="math/tex">\epsilon</script> 的概率进行探索, 即以均匀概率随机选取一个摇臂; 以 <script type="math/tex">1-\epsilon</script> 的概率进行利用, 即选择当前平均奖赏最高的摇臂(若有多个, 则随机选取一个)</p><h3 id="Softmax"><a href="#Softmax" class="headerlink" title="Softmax"></a>Softmax</h3><p>Softmax 算法基于当前已知的摇臂平均奖赏来对探索和利用进行折中</p><p>若各摇臂的平均奖赏相当, 则选取各摇臂的概率也相当; 若某些摇臂的平均奖赏明显高于其他摇臂, 则它们被选取的概率也明显更高.</p><h2 id="强化学习的分类"><a href="#强化学习的分类" class="headerlink" title="强化学习的分类"></a>强化学习的分类</h2><p><img src="https://img-blog.csdnimg.cn/20201227023548880.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyODE1ODA3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="有模型学习"><a href="#有模型学习" class="headerlink" title="有模型学习"></a>有模型学习</h3><p>考虑多步强化学习任务, 暂且先假定任务对应的马尔可夫决策过程四元组 <script type="math/tex">E=\langle X, A, P, R\rangle</script> 均为已知, 这样的情形称为“模型已知”，即机器已对环境进行了建模, 能在机器内部模拟出与环境相同或近似的状况。在已知模型的环境中学习称为“有模型学习” (model-based learning)</p><p> 此时, 对于任意状态 <script type="math/tex">x, x^{\prime}</script> 和动作 <script type="math/tex">a,</script> 在 <script type="math/tex">x</script> 状态下执行动作 <script type="math/tex">a</script> 转移到 <script type="math/tex">x^{\prime}</script> 状态的概率 <script type="math/tex">P_{x \rightarrow x^{\prime}}^{a}</script> 是已知的, 该转移所带来的奖赏 <script type="math/tex">R_{x \rightarrow x^{\prime}}^{a}</script> 也是已知的</p><p><strong>优缺点</strong></p><p>有模型学习最大的优势在于智能体能够 <strong>提前考虑来进行规划</strong>，走到每一步的时候，都提前尝试未来可能的选择，然后明确地从这些候选项中进行选择</p><p>最大的缺点就是智能体往往不能获得环境的真实模型。如果智能体想在一个场景下使用模型，那它必须完全从经验中学习，这会带来很多挑战。最大的挑战就是，智能体探索出来的模型和真实模型之间存在误差，而这种误差会导致智能体在学习到的模型中表现很好，但在真实的环境中表现得不好（甚至很差）</p><h3 id="免模型学习"><a href="#免模型学习" class="headerlink" title="免模型学习"></a>免模型学习</h3><p>在现实的强化学习任务中, 环境的转移概率、奖赏函数往往很难得知, 甚至很难知道环境中一共有多少状态</p><p>若学习算法不依赖于环境建模，则称为免模型学习(model-free learning),这比有模型学习困难的多</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>机器学习—周志华</li><li><a href="https://leovan.me/cn/2020/05/introduction-of-reinforcement-learning/" target="_blank" rel="noopener">强化学习简介 (Introduction of Reinforcement Learning)</a></li><li><a href="https://spinningup.readthedocs.io/zh_CN/latest/spinningup/rl_intro.html" target="_blank" rel="noopener">OpenAI SpinningUp</a></li><li><a href="https://blog.csdn.net/xbinworld/article/details/79372777" target="_blank" rel="noopener">强化学习方法（一）：探索-利用困境</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;强化学习简介&quot;&gt;&lt;a href=&quot;#强化学习简介&quot; class=&quot;headerlink&quot; title=&quot;强化学习简介&quot;&gt;&lt;/a&gt;强化学习简介&lt;/h1&gt;&lt;p&gt;强化学习(Reinforcement Learning，RL)是机器学习中的一个领域，是学习做什么（即如何把
      
    
    </summary>
    
    
      <category term="AI" scheme="http://yoursite.com/categories/AI/"/>
    
    
      <category term="强化学习" scheme="http://yoursite.com/tags/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Scala 的几种group集合操作</title>
    <link href="http://yoursite.com/2020/12/20/Scala%E7%9A%84%E5%87%A0%E7%A7%8Dgroup%E9%9B%86%E5%90%88%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2020/12/20/Scala%E7%9A%84%E5%87%A0%E7%A7%8Dgroup%E9%9B%86%E5%90%88%E6%93%8D%E4%BD%9C/</id>
    <published>2020-12-20T15:33:29.000Z</published>
    <updated>2020-12-20T15:33:10.284Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Scala-的几种group集合操作"><a href="#Scala-的几种group集合操作" class="headerlink" title="Scala 的几种group集合操作"></a>Scala 的几种group集合操作</h1><p>scala的集合中有如下几种group操作</p><ul><li><p><code>groupBy</code> 按特定条件对集合元素进行分类</p></li><li><p><code>grouped</code> 将集合拆分成指定长度的子集合</p></li><li><p><code>groupMap</code> 使用方法按特定条件对集合的元素进行分类并处理每个元素</p></li><li><code>groupMapReduce</code> 使用方法按特定条件对集合中的元素进行分类，分别进行处理，最后将它们reduce</li></ul><p>这些方法在<a href="https://www.scala-lang.org/api/current/scala/collection/IterableOps.html" target="_blank" rel="noopener">scala.collection.IterableOps</a>中定义</p><h2 id="groupBy"><a href="#groupBy" class="headerlink" title="groupBy"></a>groupBy</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">groupBy</span></span>[<span class="type">K</span>](f: (<span class="type">A</span>) =&gt; <span class="type">K</span>): immutable.<span class="type">Map</span>[<span class="type">K</span>, <span class="type">C</span>]</span><br></pre></td></tr></table></figure><p>返回immutable Map，每个Map由一个键和一个原始类型的值的集合组成</p><p>为了在生成的Map中处理这个值的集合，Scala提供了mapValues方法</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mapValues</span></span>[<span class="type">W</span>](f: (<span class="type">V</span>) =&gt; <span class="type">W</span>): <span class="type">Map</span>[<span class="type">K</span>, <span class="type">W</span>]</span><br></pre></td></tr></table></figure><p>这个groupBy / mapValues组合对于处理从分组生成的Map的值非常方便</p><p>但是从Scala 2.13开始，方法mapValues不再可用</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example: groupBy</span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Pet</span>(<span class="params">species: <span class="type">String</span>, name: <span class="type">String</span>, age: <span class="type">Int</span></span>)</span></span><br><span class="line"><span class="class"> </span></span><br><span class="line"><span class="class"><span class="title">val</span> <span class="title">pets</span> </span>= <span class="type">List</span>(</span><br><span class="line">  <span class="type">Pet</span>(<span class="string">"cat"</span>, <span class="string">"sassy"</span>, <span class="number">2</span>), <span class="type">Pet</span>(<span class="string">"cat"</span>, <span class="string">"bella"</span>, <span class="number">3</span>), </span><br><span class="line">  <span class="type">Pet</span>(<span class="string">"dog"</span>, <span class="string">"poppy"</span>, <span class="number">3</span>), <span class="type">Pet</span>(<span class="string">"dog"</span>, <span class="string">"bodie"</span>, <span class="number">4</span>), <span class="type">Pet</span>(<span class="string">"dog"</span>, <span class="string">"poppy"</span>, <span class="number">2</span>), </span><br><span class="line">  <span class="type">Pet</span>(<span class="string">"bird"</span>, <span class="string">"coco"</span>, <span class="number">2</span>), <span class="type">Pet</span>(<span class="string">"bird"</span>, <span class="string">"kiwi"</span>, <span class="number">1</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">pets.groupBy(_.species)</span><br><span class="line"></span><br><span class="line"><span class="comment">// res5: scala.collection.immutable.Map[String,List[Pet]] = HashMap(</span></span><br><span class="line"><span class="comment">//bird -&gt; List(Pet(bird,coco,2), Pet(bird,kiwi,1)), </span></span><br><span class="line"><span class="comment">//dog -&gt; List(Pet(dog,poppy,3), Pet(dog,bodie,4), Pet(dog,poppy,2)), </span></span><br><span class="line"><span class="comment">//cat -&gt; List(Pet(cat,sassy,2), Pet(cat,bella,3)))</span></span><br></pre></td></tr></table></figure><p>groupBy / mapValues组合</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example: groupBy and mapValues</span></span><br><span class="line">pets.groupBy(_.species).mapValues(_.map(_.name)).toMap</span><br><span class="line"></span><br><span class="line"><span class="comment">// warning: method mapValues in trait MapOps is deprecated (since 2.13.0): Use .view.mapValues(f). A future // // version will include a strict version of this method (for now, .view.mapValues(f).toMap).</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// val res7: scala.collection.immutable.Map[String,List[String]] = Map(</span></span><br><span class="line"><span class="comment">// bird -&gt; List(coco, kiwi), </span></span><br><span class="line"><span class="comment">//dog -&gt; List(poppy, bodie, poppy), </span></span><br><span class="line"><span class="comment">//cat -&gt; List(sassy, bella))</span></span><br></pre></td></tr></table></figure><h2 id="groupMap"><a href="#groupMap" class="headerlink" title="groupMap"></a>groupMap</h2><p>出现了一种新方法groupMap，按特定条件对集合的元素进行分类并处理每个元素</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">groupMap</span></span>[<span class="type">K</span>, <span class="type">B</span>](key: (<span class="type">A</span>) =&gt; <span class="type">K</span>)(f: (<span class="type">A</span>) =&gt; <span class="type">B</span>): immutable.<span class="type">Map</span>[<span class="type">K</span>, <span class="type">CC</span>[<span class="type">B</span>]]</span><br></pre></td></tr></table></figure><p>对比上面的mapValues方法<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example: groupMap</span></span><br><span class="line">pets.groupMap(_.species)(_.name)</span><br><span class="line"></span><br><span class="line"><span class="comment">// val res8: scala.collection.immutable.Map[String,List[String]] = Map(</span></span><br><span class="line"><span class="comment">//cat -&gt; List(sassy, bella), </span></span><br><span class="line"><span class="comment">//bird -&gt; List(coco, kiwi), </span></span><br><span class="line"><span class="comment">//dog -&gt; List(poppy, bodie, poppy))</span></span><br></pre></td></tr></table></figure></p><h2 id="groupMapReduce"><a href="#groupMapReduce" class="headerlink" title="groupMapReduce"></a>groupMapReduce</h2><p>有时，我们需要在对集合进行分组后对Map值进行reduce</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">groupMapReduce</span></span>[<span class="type">K</span>, <span class="type">B</span>](key: (<span class="type">A</span>) =&gt; <span class="type">K</span>)(f: (<span class="type">A</span>) =&gt; <span class="type">B</span>)(reduce: (<span class="type">B</span>, <span class="type">B</span>) =&gt; <span class="type">B</span>): immutable.<span class="type">Map</span>[<span class="type">K</span>, <span class="type">B</span>]</span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example groupMapReduce</span></span><br><span class="line">pets.groupMapReduce(_.species)(_ =&gt; <span class="number">1</span>)(_ + _)</span><br><span class="line"></span><br><span class="line"><span class="comment">//val res9: scala.collection.immutable.Map[String,Int] = Map(</span></span><br><span class="line"><span class="comment">//cat -&gt; 2, </span></span><br><span class="line"><span class="comment">//bird -&gt; 2, </span></span><br><span class="line"><span class="comment">//dog -&gt; 3)</span></span><br></pre></td></tr></table></figure><h2 id="grouped"><a href="#grouped" class="headerlink" title="grouped"></a>grouped</h2><p>集合拆分成指定长度的子集合</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">grouped</span></span>(size: <span class="type">Int</span>): <span class="type">Iterator</span>[<span class="type">C</span>]</span><br></pre></td></tr></table></figure><p>尝试将一个长度为9的集合进行切分</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)</span><br><span class="line"></span><br><span class="line">list.grouped(<span class="number">4</span>).toList</span><br><span class="line"></span><br><span class="line"><span class="comment">// val res11: List[List[Int]] = List(List(1, 2, 3, 4), List(5, 6, 7, 8), List(9))</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Scala-的几种group集合操作&quot;&gt;&lt;a href=&quot;#Scala-的几种group集合操作&quot; class=&quot;headerlink&quot; title=&quot;Scala 的几种group集合操作&quot;&gt;&lt;/a&gt;Scala 的几种group集合操作&lt;/h1&gt;&lt;p&gt;scala的
      
    
    </summary>
    
    
      <category term="BigData" scheme="http://yoursite.com/categories/BigData/"/>
    
    
      <category term="Scala" scheme="http://yoursite.com/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>Feedback Graph Convolutional Network for Skeleton-based Action Recognition</title>
    <link href="http://yoursite.com/2020/12/16/FGCN/"/>
    <id>http://yoursite.com/2020/12/16/FGCN/</id>
    <published>2020-12-15T20:42:22.000Z</published>
    <updated>2020-12-16T06:31:22.031Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Feedback-Graph-Convolutional-Network-for-Skeleton-based-Action-Recognition"><a href="#Feedback-Graph-Convolutional-Network-for-Skeleton-based-Action-Recognition" class="headerlink" title="Feedback Graph Convolutional Network for Skeleton-based Action Recognition"></a>Feedback Graph Convolutional Network for Skeleton-based Action Recognition</h1><blockquote><p>作者          | Hao Yang, Dan Yan<br>单位          | NUCTECH Company Limited<br>论文地址 ｜<a href="https://arxiv.org/abs/2003.07564" target="_blank" rel="noopener">https://arxiv.org/abs/2003.07564</a></p></blockquote><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>​    近年来，许多学者利用图卷积网络（GCN）对骨架序列进行端到端优化建模。然而，传统的gcn是前馈网络，浅层不能访问到深层的语义信息，在这篇论文中，提出一个新的网络，称为<strong>反馈图卷积网络（FGCN）</strong></p><p>这是<strong>首次</strong>将反馈机制引入GCNs和动作识别中</p><p><strong>与传统的gcn相比，FGCN具有以下优点</strong></p><ol><li><p>设计了一种多阶段的时间采样策略，以从粗到精的渐进过程提取动作识别的时空特征</p></li><li><p>提出了一种基于稠密连接的反馈图卷积块（FGCB）来引入反馈连接,它将高层语义特征传递到底层，并逐级传递时间信息，逐步建立全局时空特征模型，用于动作识别</p></li><li><p>FGCN模型提供了早期预测。在早期阶段，模型接收到关于动作的部分信息。当然，它的预测相对粗糙。将粗预测视为先验知识，指导后期特征学习，实现精确预测</p></li></ol><p>在NTU-RGB+D、NTU-RGB+D120和Northwestern-UCLA的数据集上进行了大量的实验，结果表明所提出的FGCN对动作识别是有效的。它在三个数据集上达到了最先进的性能</p><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>​    近年来，从不同终端上传的视频数量已经增加。这推动了对基于视频内容的人类行为分析的迫切需求。尤其是与RGB和光流等其他模式相比，骨架人体行为识别因其对动态环境和复杂背景的影响具有较强的适应性而吸引了许多计算机视觉研究者。早期使用骨骼进行动作识别的深度学习方法通常将骨骼数据表示为关节坐标向量序列或伪图像，然后分别由RNN或CNN建模</p><p>​    然而，这些方法并没有显式地利用相关关节之间的空间依赖性，即使空间依赖性对于理解人类行为是有用的。最近，一些方法根据连续帧的自然连接和时间边缘来构造时空图。然后他们利用GCN来模拟时空特征。然而，<strong>传统的gcn都是单个前馈网络</strong>，由整个骨架序列当作输入。这些方法很难提取出有效的时空特征，因为这些有用的信息通常被隐藏在与运动无关或未区分的片段中。例如，在“踢某物”动作中，大多数片段是“直立站立”，而在“穿鞋”动作中，大多数片段都是坐在椅子上。因此，对于低层，单通前馈网络无法访问深层语义信息。同时，输入整个骨架序列增加了模型的计算复杂度。</p><p>​    基于这一点，提出了一种新的神经网络，称为反馈图卷积网络(FGCN)，以粗到精的渐进过程从骨架数据中提取有效的时空特征，用于动作识别。<strong>FGCN是第一个将反馈机制引入GCNs和动作识别的工作</strong>。与传统的gcn相比，FGCN具有多阶段的时间采样策略，该策略将输入的骨架序列在时域内分为多个阶段，并从时域对输入的骨架片段进行稀疏采样，避免了整个骨架序列的输入。对每一级输入的空时图像进行局部卷积提取。提出了一种基于反馈图卷积块（FGCB）融合局部特征的全局时空特征建模方法。FGCB是一个局部稠密图卷积网络，每个级到下一级都有横向连接，它将反馈连接引入到传统的gcn中。从语义角度看，它是自上而下的工作方式，这使得低层卷积层能够在每个阶段访问高层的语义信息。在时域上，FGCB的反馈机制具有一系列因果关系，前一级的输出流入下一级，以调节其输入。</p><p>​    <strong>FGCN的另一个优点是它可以在总推理时间的一小部分时间内提供输出的早期预测</strong>。这在许多应用中都很有价值，例如机器人或自动驾驶，在这些应用中，延迟时间是非常关键的。早期预测是所提出的多阶段从粗到细逐步优化的结果。在早期阶段，FGCN只提供了一部分骨架序列，而且有关该行为的信息有限，因此其推断相对粗糙。这些推理被视为在以后阶段指导特征学习的先验知识。在后期阶段，该模型接收到更完整的行为信息和先前推理的引导者信息，从而输出更精确的推理。提出了几种时域融合策略，将局部预测融合到视频级预测中。这些策略使网络在渐进过程中得到优化。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="反馈图卷积网络"><a href="#反馈图卷积网络" class="headerlink" title="反馈图卷积网络"></a>反馈图卷积网络</h3><p>​    传统的基于GCNs的动作识别方法都是在一个前馈网络中输入整个骨架序列。然而，当输入整个骨架序列时，有用的信息通常隐藏在与运动无关且无差别的片段中。单通前馈网络不能在浅层访问语义信息。为了解决这些问题，提出了一种反馈图卷积网络（FGCN），该网络通过多级递进过程提取时空特征。具体地说，FGCN设计了一种多阶段的时间采样策略来从骨架数据中稀疏地采样一系列输入片段，而不是直接对整个骨架序列进行操作。这些片段首先被输入到图的卷积层中以提取局部时空特征。然后，提出了一种反馈图卷积块（FGCB），通过将前一级的高级信息传输到下一级来调制其输入，从而融合来自多个时间阶段的局部时空特征。最后，提出了几种时间融合策略，将所有时间阶段的局部预测进行融合，给出一个视频级的预测。</p><p><img src="https://img-blog.csdnimg.cn/20201216040747929.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyODE1ODA3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201216040804695.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyODE1ODA3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="反馈图卷积块（FGCB"><a href="#反馈图卷积块（FGCB" class="headerlink" title="反馈图卷积块（FGCB)"></a>反馈图卷积块（FGCB)</h3><p>​    反馈模块FGCB是FGCN模型的核心部分。一方面，FGCB将高层语义信息传回低层，以细化其编码特征。另一方面，前一级的输出流入下一级，以调节其输入。为了使FGCB能够有效地将信息从高层传输到低层，以及从前一个阶段传输到下一个阶段，提出了一个密集连接的局部图卷积网络，它增加了从每一层到所有后续层的连接</p><p><img src="https://img-blog.csdnimg.cn/20201216040814776.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyODE1ODA3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>设计了四个消融实验来评估不同超参数、结构和输入对FGCN模型性能的影响。这些消融实验都是在NTU-RGB+D上进行的</p><h3 id="实验细节"><a href="#实验细节" class="headerlink" title="实验细节"></a>实验细节</h3><p>​    所有实验均采用PyTorch深度学习框架实现。训练过程中采用随机梯度下降（SGD）优化器，batch-size为32，momentum为0.9，初始学习率为0.1。在第40和60 个epoch，学习率除以10。训练过程在第80 epoch结束</p><p>​    输入的视频在时间上分为五个阶段，每个阶段随机抽取64个连续的帧组成一个输入片段。十个图卷积层堆叠在反馈块FGCB的前面，这些层具有与ST-GCN中的图卷积层相同的配置。FGCB有四个图形卷积层（即L=4）,将它们的时空核大小和输出通道分别设置为ks=3、kt=3和m=256<br><img src="https://img-blog.csdnimg.cn/20201216040830492.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyODE1ODA3,size_16,color_FFFFFF,t_70" alt="请添加图片描述"><br><img src="https://img-blog.csdnimg.cn/20201216040830441.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyODE1ODA3,size_16,color_FFFFFF,t_70" alt="请添加图片描述"><br><img src="https://img-blog.csdnimg.cn/20201216040830561.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyODE1ODA3,size_16,color_FFFFFF,t_70" alt="请添加图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Feedback-Graph-Convolutional-Network-for-Skeleton-based-Action-Recognition&quot;&gt;&lt;a href=&quot;#Feedback-Graph-Convolutional-Network-for-Skele
      
    
    </summary>
    
    
      <category term="Paper" scheme="http://yoursite.com/categories/Paper/"/>
    
    
      <category term="Paper" scheme="http://yoursite.com/tags/Paper/"/>
    
      <category term="ActionRecognition" scheme="http://yoursite.com/tags/ActionRecognition/"/>
    
  </entry>
  
  <entry>
    <title>Temporal Extension Module for Skeleton-Based Action Recognition</title>
    <link href="http://yoursite.com/2020/12/10/TEM/"/>
    <id>http://yoursite.com/2020/12/10/TEM/</id>
    <published>2020-12-09T22:42:22.000Z</published>
    <updated>2020-12-09T22:35:28.561Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Temporal-Extension-Module-for-Skeleton-Based-Action-Recognition"><a href="#Temporal-Extension-Module-for-Skeleton-Based-Action-Recognition" class="headerlink" title="Temporal Extension Module for Skeleton-Based Action Recognition"></a>Temporal Extension Module for Skeleton-Based Action Recognition</h1><blockquote><p>作者 | Yuya Obinata and Takuma Yamamoto<br>单位         | FUJITSU LABORATORIES LTD<br>论文地址｜<a href="https://arxiv.org/abs/2003.08951" target="_blank" rel="noopener">https://arxiv.org/abs/2003.08951</a><br>ICPR2020</p></blockquote><p>在st-gcn的基础上开发了一个模块，在帧与帧之间相邻的关节点之间也添加连接，好处在于和其他网络结合起来很方便，对于性能也有一定的提高</p><p>但其实很多sota的模型都已经考虑过帧间关节点的链接，同时扩展到了多个尺度，不仅仅是帧间邻居关节点相连</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>提出了一个用于基于骨架的动作识别的的时域扩展模块</p><p><strong>现有的方法试图在帧内表示更合适的空间图，但忽略了帧间时间图的优化</strong></p><p>具体来说，这些方法只连接帧间同一关节对应的顶点。在这篇论文中，着重于在帧间添加与相邻多个顶点的连接</p><p>是提取人体运动中多个关节的相关特征的一种简单而有效的方法</p><p>主要贡献如下</p><ul><li>提出了一个时间扩展模块，用于帧间时态图的扩展。该模块在提取人体运动中连接的多个相邻关节的相关特征时简单而有效。</li><li>在消融实验中的展示了TEM有效性</li><li>达到了SOTA</li></ul><h2 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h2><p>时空图卷积网络（ST-GCN）是第一个使用GCN对骨架序列进行动作识别的方法</p><p><img src="https://img-blog.csdnimg.cn/2020121006314185.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyODE1ODA3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>ST-GCN包括一个空间图和一个时间图，直接输入一个骨架序列，并从帧内和帧间的关节处提取特征</p><p>在这项工作中，着重于扩展时间图，连接相邻的多个顶点以及帧间（右）上的同一个顶点。在帧内提出了更合适的空间图，性能得到了显著提高。然而，这些方法忽略了帧间时间图的优化</p><p>传统的GCN方法将只对应于同一关节的顶点之间的时间维连接起来，该方法对于提取同一关节轨迹特征具有一定的效果，然而，由于过于简单不太能够提取帧间各关节间相关运动的特征</p><p><strong>研究目标</strong><br>优化空间图和时间图，以进一步提高性能<br>TEM模块不仅直接将边添加到同一个顶点，而且还直接向相邻的多个顶点添加边，并基于帧间相同的多个顶点计算卷积</p><h2 id="时间扩展模块"><a href="#时间扩展模块" class="headerlink" title="时间扩展模块"></a>时间扩展模块<img src="https://img-blog.csdnimg.cn/20201210063210320.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyODE1ODA3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></h2><p>在ST-GCN中加入了这个方法的模块，ST-GCN包括多层时空图卷积操作，将TEM放在空间卷积和时间卷积层中</p><p>以同样的方式很容易地TEM模块实现到基于时空图卷积的网络中</p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验<img src="https://img-blog.csdnimg.cn/20201210063232136.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyODE1ODA3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></h2><p>加上这个模块后有一定的性能提升</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Temporal-Extension-Module-for-Skeleton-Based-Action-Recognition&quot;&gt;&lt;a href=&quot;#Temporal-Extension-Module-for-Skeleton-Based-Action-Recog
      
    
    </summary>
    
    
      <category term="Paper" scheme="http://yoursite.com/categories/Paper/"/>
    
    
      <category term="Paper" scheme="http://yoursite.com/tags/Paper/"/>
    
      <category term="ActionRecognition" scheme="http://yoursite.com/tags/ActionRecognition/"/>
    
  </entry>
  
  <entry>
    <title>Contextual Residual Aggregation for Ultra High-Resolution Image Inpainting</title>
    <link href="http://yoursite.com/2020/12/09/CRA%20_for_image_inpanting/"/>
    <id>http://yoursite.com/2020/12/09/CRA%20_for_image_inpanting/</id>
    <published>2020-12-09T10:02:22.000Z</published>
    <updated>2020-12-09T10:02:22.948Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Contextual-Residual-Aggregation-for-Ultra-High-Resolution-Image-Inpainting"><a href="#Contextual-Residual-Aggregation-for-Ultra-High-Resolution-Image-Inpainting" class="headerlink" title="Contextual Residual Aggregation for Ultra High-Resolution Image Inpainting"></a>Contextual Residual Aggregation for Ultra High-Resolution Image Inpainting</h1><blockquote><p>作者 | Zili Yi, Qiang Tang, Shekoofeh Azizi, Daesik Jang, Zhan Xu<br>单位 | 华为技术有限公司（加拿大）<br>代码 | <a href="https://github.com/Ascend-Huawei/Ascend-Canada/tree/master/Models/Research_HiFIll_Model" target="_blank" rel="noopener">https://github.com/Ascend-Huawei/Ascend-Canada/tree/master/Models/Research_HiFIll_Model</a><br>论文地址｜<a href="https://arxiv.org/abs/2005.09704" target="_blank" rel="noopener">https://arxiv.org/abs/2005.09704</a><br>备注 | CVPR 2020 Oral </p></blockquote><h2 id="图像修复"><a href="#图像修复" class="headerlink" title="图像修复"></a>图像修复</h2><p>自动填充图像中缺失部分</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ul><li>调整目标位置</li><li>移除不想要的元素</li><li>修复损坏的图像</li></ul><p><img src="https://img-blog.csdnimg.cn/2020120917523752.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyODE1ODA3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="当前的方法"><a href="#当前的方法" class="headerlink" title="当前的方法"></a>当前的方法</h3><ol><li><p>通过复制来填充</p><ul><li><p>从缺失部分附近“借”像素来进行填充</p></li><li><p>e.g., PatchMatch, diffusion-based</p></li></ul></li><li>通过建模来填充<ul><li>数据驱动的方式来学习缺失的像素</li><li>e.g., PixelRNN,FCN</li></ul></li><li>结合上面两种<ul><li>e.g., DeepFill, Patch-Swap</li><li>这篇文章的方法</li></ul></li></ol><h4 id="当前基于学习的方法的不足"><a href="#当前基于学习的方法的不足" class="headerlink" title="当前基于学习的方法的不足"></a>当前基于学习的方法的不足</h4><ul><li>不能够去处理高分辨率图像<ul><li>训练困难</li><li>GPU/NPU内存的限制</li><li>缺少高分辨率的训练数据集</li></ul></li></ul><p><img src="https://img-blog.csdnimg.cn/20201209175251686.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyODE1ODA3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="论文方法"><a href="#论文方法" class="headerlink" title="论文方法"></a>论文方法</h2><p>提出了一种上下文残差聚合（CRA）机制，该机制可以通过对上下文补丁中的残差进行加权聚合来生成丢失内容的高频残差，因此网络的训练仅需要低分辨率即可</p><p>由于神经网络的卷积层仅需要在低分辨率的输入和输出上进行操作，因此降低了内存和计算能力的成本</p><p>此外，还减轻了对高分辨率训练数据集的需求</p><p><strong>通过3阶段的pipeline实现高分辨率图像的修复</strong></p><ol><li><p>由生成器（Generator）得到低分辨率的修补好的图像</p></li><li><p>通过残差聚合模块得到高频残差</p></li><li><p>合并高频残差和低分辨率修补结果得到高分辨率修补图像</p></li></ol><h3 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h3><p><img src="https://img-blog.csdnimg.cn/20201209175306706.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyODE1ODA3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="生成器（Generator）"><a href="#生成器（Generator）" class="headerlink" title="生成器（Generator）"></a>生成器（Generator）</h4><p><strong>两阶段的coarse-to-fine网络</strong></p><p>coarse network输入下采样到256×256的带mask图像，会产生粗略的缺失内容</p><p>fine network 通过<strong>Attention Computing Module (ACM)</strong>和<strong>Attention Transfer Module (ATM)</strong>得到缺失部分内外的关系得分，输出512×512的修复结果</p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p><img src="https://img-blog.csdnimg.cn/20201209175321384.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyODE1ODA3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>这篇论文的方法在图片分辨率大于1K的情况下修复效率和质量达到了最好</strong></p><p><img src="https://img-blog.csdnimg.cn/20201209175343504.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyODE1ODA3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="使用预训练好模型的测试结果"><a href="#使用预训练好模型的测试结果" class="headerlink" title="使用预训练好模型的测试结果"></a>使用预训练好模型的测试结果</h4><p>结果在缺失部分很大，且上下文环境复杂的情况下，效果看起来并没有很好</p><p>在背景单一的风景照中效果很不错<br><img src="https://img-blog.csdnimg.cn/20201209175353108.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyODE1ODA3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>提出了一种新颖的上下文残留聚合技术，可对超高分辨率图像进行更高效和高质量的修复</p></li><li><p>把大图下采样到 512×512 ，在分辨率为512×512的小图像上进行图像修复，然后在高分辨率图像上进行推理得到修复效果良好的大图</p></li><li>与其他数据驱动方法不同，分辨率和孔尺寸的增加不会降低修补质量，也不会显着增加我们框架中的处理时间</li><li>到目前为止，是唯一能够在超高分辨率图像(4K至8K)上进行端到端修复的基于学习的技术</li></ul><p>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Contextual-Residual-Aggregation-for-Ultra-High-Resolution-Image-Inpainting&quot;&gt;&lt;a href=&quot;#Contextual-Residual-Aggregation-for-Ultra-High
      
    
    </summary>
    
    
      <category term="Paper" scheme="http://yoursite.com/categories/Paper/"/>
    
    
      <category term="Paper" scheme="http://yoursite.com/tags/Paper/"/>
    
      <category term="ImageInpainting" scheme="http://yoursite.com/tags/ImageInpainting/"/>
    
  </entry>
  
  <entry>
    <title>K-means聚类算法</title>
    <link href="http://yoursite.com/2020/11/25/K-means%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2020/11/25/K-means%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95/</id>
    <published>2020-11-25T10:34:22.000Z</published>
    <updated>2020-11-25T10:45:24.703Z</updated>
    
    <content type="html"><![CDATA[<h1 id="K-means聚类算法"><a href="#K-means聚类算法" class="headerlink" title="K-means聚类算法"></a>K-means聚类算法</h1><h2 id="聚类"><a href="#聚类" class="headerlink" title="聚类"></a>聚类</h2><blockquote><p>在无监督学习中, 训练样本的标记信息是未知的, 目标是通过对无标记训练样本的学习来揭示数据的内在性质及规律, 为进一步的数据分析提供基础，此类学习任务中研究最多、应用最广的是“聚类”(clustering)</p></blockquote><p>聚类试图将数据集中的样本划分为若干个通常是不相交的子集, 每个子集称为一个“簇”(cluster)</p><p>通过这样的划分, 每个簇可能对应于一些潜在的概念(类别), 需说明的是, 这些概念对聚类算法而言事先是未知的, 聚类过程仅能自动形成簇结构, 簇所对应的概念语义需由使用者来把握</p><p>关于簇的完整定义尚未达成共识，传统的定义如下</p><ul><li><p>同一簇中的实例必须尽可能相似</p></li><li><p>不同簇中的实例必须尽可能不同</p></li><li><p>相似度和相异度的度量必须清楚并具有实际意义</p></li></ul><h3 id="性能度量"><a href="#性能度量" class="headerlink" title="性能度量"></a>性能度量</h3><p>聚类性能度量大致有两类</p><ul><li><p>将聚类结果与某个参考模型进行比较, 称为“外部指标” (external index)</p></li><li><p>直接考察聚类结果而不利用任何参考模型, 称为“内部指标” (internalindex)</p></li></ul><h4 id="外部指标"><a href="#外部指标" class="headerlink" title="外部指标"></a>外部指标</h4><p>对数据集 <script type="math/tex">D=\left\{\boldsymbol{x}_{1}, \boldsymbol{x}_{2}, \ldots, \boldsymbol{x}_{m}\right\},</script> 假定通过聚类给出的族划分为 <script type="math/tex">\mathcal{C}=\left\{C_{1},C_{2}, \ldots, C_{k}\right\},</script> 参考模型给出的族划分为 <script type="math/tex">\mathcal{C}^{*}=\left\{C_{1}^{*}, C_{2}^{*}, \ldots, C_{s}^{*}\right\} .</script> 相应地, 令 <script type="math/tex">\boldsymbol{\lambda}</script> 与<script type="math/tex">\lambda^{*}</script> 分别表示与 <script type="math/tex">\mathcal{C}</script> 和 <script type="math/tex">\mathcal{C}^{*}</script> 对应的族标记向量. 我们将样本两两配对考虑, 定义</p><script type="math/tex; mode=display">\begin{aligned}a &\left.=|S S|, \quad S S=\left\{\left(\boldsymbol{x}_{i}, \boldsymbol{x}_{j}\right) \mid \lambda_{i}=\lambda_{j}, \lambda_{i}^{*}=\lambda_{j}^{*}, i<j\right)\right\} \\b &\left.=|S D|, \quad S D=\left\{\left(\boldsymbol{x}_{i}, \boldsymbol{x}_{j}\right) \mid \lambda_{i}=\lambda_{j}, \lambda_{i}^{*} \neq \lambda_{j}^{*}, i<j\right)\right\} \\c &\left.=|D S|, \quad D S=\left\{\left(\boldsymbol{x}_{i}, \boldsymbol{x}_{j}\right) \mid \lambda_{i} \neq \lambda_{j}, \lambda_{i}^{*}=\lambda_{j}^{*}, i<j\right)\right\} \\d &\left.=|D D|, \quad D D=\left\{\left(\boldsymbol{x}_{i}, \boldsymbol{x}_{j}\right) \mid \lambda_{i} \neq \lambda_{j}, \lambda_{i}^{*} \neq \lambda_{j}^{*}, i<j\right)\right\}\end{aligned}</script><p>其中集合 <script type="math/tex">SS</script> 包含了在 <script type="math/tex">\mathcal{C}</script> 中隶属于相同族且在 <script type="math/tex">\mathcal{C}^{*}</script> 中也隶属于相同族的样本</p><p>集合 <script type="math/tex">SD</script> 包含了在 <script type="math/tex">\mathcal{C}</script> 中隶属于相同族但在 <script type="math/tex">\mathcal{C}^{*}</script> 中隶属于不同族的样本</p><p>集合 <script type="math/tex">DS</script> 包含了在 <script type="math/tex">\mathcal{C}</script> 中隶属于 不同族但在 <script type="math/tex">\mathcal{C}^{*}</script> 中隶属于相同族的样本</p><p>集合 <script type="math/tex">DD</script> 包含了在 <script type="math/tex">\mathcal{C}</script> 中隶属于不同族在 <script type="math/tex">\mathcal{C}^{*}</script> 中也隶属于不同族的样本</p><p>可计算出下面这些聚类性能度量外部指标</p><ul><li>Jaccard系数</li></ul><script type="math/tex; mode=display">\mathrm{JC}=\frac{a}{a+b+c}</script><ul><li><p>FM指数（Fowlkes and Mallows Index,FMI）</p><script type="math/tex; mode=display">\mathrm{FMI}=\sqrt{\frac{a}{a+b} \cdot \frac{a}{a+c}}</script></li><li><p>Rand指数(Rand Index,RI)</p><script type="math/tex; mode=display">\mathrm{RI}=\frac{2(a+d)}{m(m-1)}</script></li></ul><p>显然上述性能度量的结果值均在[0，1]区间，值越大越好</p><h4 id="内部指标"><a href="#内部指标" class="headerlink" title="内部指标"></a>内部指标</h4><p>考虑聚类结果的族划分 <script type="math/tex">\mathcal{C}=\left\{C_{1}, C_{2}, \ldots, C_{k}\right\},</script> 定义</p><script type="math/tex; mode=display">\begin{aligned}\operatorname{avg}(C) &=\frac{2}{|C|(|C|-1)} \sum_{1 \leqslant i<j \leqslant|C|} \operatorname{dist}\left(\boldsymbol{x}_{i}, \boldsymbol{x}_{j}\right) \\\operatorname{diam}(C) &=\max _{1 \leqslant i<j \leqslant|C|} \operatorname{dist}\left(\boldsymbol{x}_{i}, \boldsymbol{x}_{j}\right) \\d_{\min }\left(C_{i}, C_{j}\right) &=\min _{\boldsymbol{x}_{i} \in C_{i}, \boldsymbol{x}_{j} \in C_{j}} \operatorname{dist}\left(\boldsymbol{x}_{i}, \boldsymbol{x}_{j}\right) \\d_{\operatorname{cen}}\left(C_{i}, C_{j}\right) &=\operatorname{dist}\left(\boldsymbol{\mu}_{i}, \boldsymbol{\mu}_{j}\right)\end{aligned}</script><p>其中dist <script type="math/tex">(\cdot, \cdot)</script> 用于计算两个样本之间的距离<script type="math/tex">\boldsymbol{\mu}</script><br>族 <script type="math/tex">C</script> 的中心点 <script type="math/tex">\boldsymbol{\mu}=</script> <script type="math/tex">\frac{1}{|C|} \sum_{1 \leqslant i \leqslant|C|} \boldsymbol{x}_{i}</script></p><p>族 <script type="math/tex">C</script> 内样本间的平均距离<script type="math/tex">\operatorname{avg}(C)</script> </p><p>族 <script type="math/tex">C</script> 内样本间的最远距离<script type="math/tex">\operatorname{diam}(C)</script> </p><p>对应于族 <script type="math/tex">C_{i}</script> 与族 <script type="math/tex">C_{j}</script> 最近样本间的距离 <script type="math/tex">d_{\min }\left(C_{i}, C_{j}\right)</script></p><p>对应于族 <script type="math/tex">C_{i}</script> 与族 <script type="math/tex">C_{j}</script> 中心点间的距离<script type="math/tex">d_{\mathrm{cen}}\left(C_{i}, C_{j}\right)</script> </p><p>可计算出下面这些聚类性能度量内部指标</p><ul><li>DB 指数(Davies-Bouldin Index, DBI)<script type="math/tex; mode=display">\mathrm{DBI}=\frac{1}{k} \sum_{i=1}^{k} \max _{j \neq i}\left(\frac{\operatorname{avg}\left(C_{i}\right)+\operatorname{avg}\left(C_{j}\right)}{d_{\mathrm{cen}}\left(\mu_{i}, \mu_{j}\right)}\right)</script></li><li>Dunn 指数(Dunn Index, DI)<script type="math/tex; mode=display">\mathrm{DI}=\min _{1 \leqslant i \leqslant k}\left\{\min _{j \neq i}\left(\frac{d_{\min }\left(C_{i}, C_{j}\right)}{\max _{1 \leqslant l \leqslant k} \operatorname{diam}\left(C_{l}\right)}\right)\right\}</script>显然, DBI 的值越小越好, 而 DI 则相反, 值越大越好</li></ul><h3 id="距离度量"><a href="#距离度量" class="headerlink" title="距离度量"></a>距离度量</h3><p>可参考<a href="https://blog.csdn.net/qq_32815807/article/details/109172509" target="_blank" rel="noopener">k-近邻算法（KNN）</a>中距离度量部分</p><h3 id="常见的聚类算法"><a href="#常见的聚类算法" class="headerlink" title="常见的聚类算法"></a>常见的聚类算法</h3><h4 id="原型聚类"><a href="#原型聚类" class="headerlink" title="原型聚类"></a>原型聚类</h4><p>原型聚类亦称“基于原型的聚类” (prototype-based clustering)</p><p>假设聚类结构能通过一组原型（指样本空间中具有代表性的点）刻画, 通常情形下，算法先对原型进行初始化, 然后对原型进行迭代更新求解. 采用不同的原型表示、不同的求解方式将产生不同的算法，下面是几种著名的原型聚类算法</p><ul><li>k-means</li><li>学习向量量化（Learning Vector Quantization,LVQ）</li><li>高斯混合聚类（Mixture-of-Guassian）</li></ul><h4 id="层次聚类"><a href="#层次聚类" class="headerlink" title="层次聚类"></a>层次聚类</h4><p>层次聚类(hierarchical clustering)试图在不同层次对数据集进行划分，从而形成树形的聚类结构</p><p>数据集的划分可采用“自底向上”的聚合策略，它将最相似的两个点合并，直到所有点都合并到一个群集中为止</p><p>也可采用“自顶向下”的分拆策略，它以所有点作为一个簇开始，并在每一步拆分相似度最低的簇，直到仅剩下单个数据点</p><p>在分层聚类中，聚类数（k）通常由用户预先确定，通过在指定深度切割树状图来分配聚类，从而得到k组较小的树状图</p><p>与许多分区聚类技术不同，分层聚类是<strong>确定性</strong>过程，这意味着当您对相同的输入数据运行两次算法时，聚类分配不会改变</p><p>层次聚类方法的<strong>优点</strong>包括</p><ul><li>它们通常会揭示有关数据对象之间的更详细的信息。</li><li>它们提供了<strong>可解释的树状图</strong>。</li></ul><p>层次聚类方法的<strong>缺点</strong>包括</p><ul><li>算法复杂度高</li><li>对<strong>噪音</strong>和<strong>异常值</strong>很敏感</li></ul><h4 id="基于密度的聚类"><a href="#基于密度的聚类" class="headerlink" title="基于密度的聚类"></a>基于密度的聚类</h4><p>基于密度的聚类根据区域中数据点的密度确定聚类分配,在高密度的数据点被低密度区域分隔的地方分配簇</p><p>与其他类别的聚类不同，该方法不需要用户指定群集数量，而是有一个基于距离的参数充当可调阈值来确定是否将接近的点视为簇成员</p><p>DBSCAN是一种著名的密度聚类算法，它基于一组领域参数来刻画样本分布的紧密程度</p><p>基于密度的聚类方法的<strong>优点</strong>包括</p><ul><li>他们擅长识别<strong>非类圆型</strong>簇。</li><li>它们可以抵抗<strong>异常值</strong>。</li></ul><p>基于密度的聚类方法的<strong>缺点</strong>包括</p><ul><li>它们不太适合在<strong>高维空间中聚类</strong></li><li>很难确定<strong>密度不同的</strong>簇。</li></ul><h2 id="K-means"><a href="#K-means" class="headerlink" title="K-means"></a>K-means</h2><p>k均值聚类算法（k-means clustering algorithm）是一种迭代求解的聚类分析算法</p><p>它试图将数据集划分为K个不同的非重叠子组(簇)，其中每个数据点只属于一个组</p><p>同时使得簇内数据点尽可能相似，还要尽可能保持簇之间的差异</p><p>聚类分配的质量是通过计算质心<strong>收敛</strong>后的平方误差和（sum of the squared error,SSE）来确定的，或者与先前的迭代分配相符</p><p>SSE定义为每个点与其最接近的质心的欧几里德距离平方的总和，k-means的目的是尝试最小化该值</p><p>下图显示了在同一数据集上两次不同的<em>k</em> -means算法运行的前五个迭代中的质心和SSE更新：</p><p><img src="https://img-blog.csdnimg.cn/20201125183206829.gif#pic_center" alt="在这里插入图片描述"></p><p>此图的目的是表明质心的初始化是重要的一步，随机初始化步骤导致<em>k</em> -means算法<strong>不确定</strong>，这意味着如果您在同一数据集上运行两次相同的算法，则簇分配将有所不同</p><p>研究人员通常会对整个<em>k</em>均值算法进行几次初始化，并从具有最低SSE的初始化</p><h3 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h3><ol><li>指定簇数K</li><li>首先对数据集shuffle，然后为质心随机选择<em>K个</em>数据点</li><li>不断迭代，直到质心没有变化，即数据点分配给群集的操作没有改变<ul><li>计算数据点和所有质心之间的平方距离之和</li><li>将每个数据点分配给最近的群集（质心）</li><li>通过获取属于每个群集的所有数据点的平均值，计算群集的质心</li></ul></li></ol><p>k-means解决问题的方法称为期望最大化（Expectation Maximization,EM）<br>目标函数是</p><script type="math/tex; mode=display">E=\sum_{i=1}^{k} \sum_{\boldsymbol{x} \in C_{i}}\left\|\boldsymbol{x}-\boldsymbol{\mu}_{i}\right\|_{2}^{2}</script><p>其中 <script type="math/tex">\mu_{i}=\frac{1}{|C_{i}|} \sum_{x \in C_{i}} x</script> 是族 <script type="math/tex">C_{i}</script> 的均值向量<br>最小化目标函数并不容易, 找到它的最优解需考察样本集 <script type="math/tex">D</script> 所有可能的族划分, 这是一个 <script type="math/tex">\mathrm{NP}</script> 难问题</p><p>因此k-means算法采用了贪心策略, 通过迭代优化来近似求解</p><h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><ul><li>类别数 <script type="math/tex">k</script> 值需要预先指定，而在实际应用中最优的 <script type="math/tex">k</script> 值是不知道的,解决这个问题的一个方法是尝试用不同的 <script type="math/tex">k</script> 值聚类, 检验各自得到聚类结果的质量, 推测最优的 <script type="math/tex">k</script> 值</li><li><p>由于包括kmeans在内的聚类算法使用基于距离的度量来确定数据点之间的相似性，因此建议对数据进行标准化</p></li><li><p>由于kmeans算法可能停留在局部最优而不收敛于全局最优，因此不同的初始化可能导致不同的聚类，建议使用不同的质心初始化来运行算法，并选择产生较低SSE的运行结果</p></li></ul><h3 id="找到合适的K"><a href="#找到合适的K" class="headerlink" title="找到合适的K"></a>找到合适的K</h3><p>下面将介绍两个指标，这些指标可能使我们更直接的观察k的取值</p><h4 id="肘部法则（Elbow-Method"><a href="#肘部法则（Elbow-Method" class="headerlink" title="肘部法则（Elbow Method)"></a>肘部法则（Elbow Method)</h4><p>k-means是以最小化样本与质点平方误差作为目标函数，将每个簇的质点与簇内样本点的平方距离误差和称为畸变程度(distortions)，那么，对于一个簇，它的畸变程度越低，代表簇内成员越紧密，畸变程度越高，代表簇内结构越松散</p><p>畸变程度会随着类别的增加而降低，但对于有一定区分度的数据，在达到某个临界点时畸变程度会得到极大改善，之后缓慢下降，这个临界点就可以考虑为聚类性能较好的点</p><p> <img src="https://img-blog.csdnimg.cn/2020112518295967.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyODE1ODA3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>存在当曲线是单调递减的时仍然很难找出合适的簇数的可能</p><h4 id="轮廓系数（Silhouette-Coefficient）"><a href="#轮廓系数（Silhouette-Coefficient）" class="headerlink" title="轮廓系数（Silhouette Coefficient）"></a>轮廓系数（Silhouette Coefficient）</h4><p>轮廓系数是聚类结合和分离程序的评价指标，它基于两个因素来量化数据点适合其分配的簇的程度</p><ol><li><p>数据点与簇中其他点的距离有多近</p></li><li><p>数据点与其他簇中的点有多远</p></li></ol><p>计算距同一簇中所有数据点的平均距离<script type="math/tex">a_i</script><br>计算到最近的簇中所有数据点的平均距离<script type="math/tex">b_i</script></p><script type="math/tex; mode=display">\frac{b^{i}-a^{i}}{\max \left(a^{i}, b^{i}\right)}</script><p>轮廓系数值介于-1和1之间，越接近1表示样本所在簇合理</p><p>若近似为0，则说明样本在两个簇的边界上</p><p><img src="https://img-blog.csdnimg.cn/2020112518301011.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyODE1ODA3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>如果簇是类圆形的，那么Kmeans算法是可以胜任的，它总是尝试在质心周围构造一个不错的球形</p><p>但这这意味着，当群集具有复杂的几何形状时，Kmeans的表现不好，如下<br><img src="https://img-blog.csdnimg.cn/20201125183024585.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyODE1ODA3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>不出所料，kmeans无法找出两个数据集的正确聚类</p><p>但是，如果我们使用核方法，将其转换为高维表示从而使数据线性可分离，则可以帮助kmeans完美地聚类此类数据集<br><img src="https://img-blog.csdnimg.cn/20201125183139392.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyODE1ODA3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding = utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KMeans</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,n_clusters, max_iters=<span class="number">100</span>, random_state=<span class="number">666</span>)</span>:</span></span><br><span class="line">        <span class="string">"""初始化Kmeans模型"""</span></span><br><span class="line">        self.n_clusters = n_clusters</span><br><span class="line">        self.max_iters = max_iters</span><br><span class="line">        self.random_state = random_state</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initializ_centroids</span><span class="params">(self, X)</span>:</span></span><br><span class="line">        np.random.RandomState(self.random_state)</span><br><span class="line">        random_idx = np.random.permutation(X.shape[<span class="number">0</span>])</span><br><span class="line">        centroids = X[random_idx[:self.n_clusters]]</span><br><span class="line">        <span class="keyword">return</span> centroids</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compute_centroids</span><span class="params">(self, X, labels)</span>:</span></span><br><span class="line">        centroids = np.zeros((self.n_clusters, X.shape[<span class="number">1</span>]))</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(self.n_clusters):</span><br><span class="line">            centroids[k, :] = np.mean(X[labels == k, :], axis=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> centroids</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compute_distance</span><span class="params">(self, X, centroids)</span>:</span></span><br><span class="line">        distance = np.zeros((X.shape[<span class="number">0</span>], self.n_clusters))</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(self.n_clusters):</span><br><span class="line">            row_norm = np.linalg.norm(X - centroids[k, :], axis=<span class="number">1</span>)</span><br><span class="line">            distance[:, k] = np.square(row_norm)</span><br><span class="line">        <span class="keyword">return</span> distance</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_closest_cluster</span><span class="params">(self, distance)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> np.argmin(distance, axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compute_sse</span><span class="params">(self, X, labels, centroids)</span>:</span></span><br><span class="line">        distance = np.zeros(X.shape[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(self.n_clusters):</span><br><span class="line">            distance[labels == k] = np.linalg.norm(X[labels == k] - centroids[k], axis=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> np.sum(np.square(distance))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fit</span><span class="params">(self, X)</span>:</span></span><br><span class="line">        self.centroids = self.initializ_centroids(X)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.max_iters):</span><br><span class="line">            old_centroids = self.centroids</span><br><span class="line">            distance = self.compute_distance(X, old_centroids)</span><br><span class="line">            self.labels = self.find_closest_cluster(distance)</span><br><span class="line">            self.centroids = self.compute_centroids(X, self.labels)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> np.all(old_centroids == self.centroids):</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        self.error = self.compute_sse(X, self.labels, self.centroids)</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(self, X_predict)</span>:</span></span><br><span class="line">        distance = self.compute_distance(X, old_centroids)</span><br><span class="line">        <span class="keyword">return</span> self.find_closest_cluster(distance)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> make_blobs</span><br><span class="line">    <span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line">    features, true_labels = make_blobs(</span><br><span class="line">        n_samples=<span class="number">200</span>,</span><br><span class="line">        n_features=<span class="number">2</span>,</span><br><span class="line">        centers=<span class="number">3</span>,</span><br><span class="line">        cluster_std=<span class="number">2.75</span>,</span><br><span class="line">        random_state=<span class="number">42</span></span><br><span class="line">    )</span><br><span class="line">    scaler = StandardScaler()</span><br><span class="line">    scaled_features = scaler.fit_transform(features)</span><br><span class="line"></span><br><span class="line">    kmeans = KMeans(</span><br><span class="line">        n_clusters=<span class="number">3</span>,</span><br><span class="line">        max_iters=<span class="number">300</span>,</span><br><span class="line">        random_state=<span class="number">42</span></span><br><span class="line">    )</span><br><span class="line">    kmeans.fit(scaled_features)</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>机器学习-周志华</p><p><a href="https://realpython.com/k-means-clustering-python/#writing-your-first-k-means-clustering-code-in-python" target="_blank" rel="noopener">K-Means Clustering in Python: A Practical Guide</a></p><p><a href="https://towardsdatascience.com/k-means-clustering-algorithm-applications-evaluation-methods-and-drawbacks-aa03e644b48a" target="_blank" rel="noopener">K-means Clustering: Algorithm, Applications, Evaluation Methods, and Drawbacks</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;K-means聚类算法&quot;&gt;&lt;a href=&quot;#K-means聚类算法&quot; class=&quot;headerlink&quot; title=&quot;K-means聚类算法&quot;&gt;&lt;/a&gt;K-means聚类算法&lt;/h1&gt;&lt;h2 id=&quot;聚类&quot;&gt;&lt;a href=&quot;#聚类&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="AI" scheme="http://yoursite.com/categories/AI/"/>
    
    
      <category term="Algorithms" scheme="http://yoursite.com/tags/Algorithms/"/>
    
      <category term="AI" scheme="http://yoursite.com/tags/AI/"/>
    
      <category term="KMeans" scheme="http://yoursite.com/tags/KMeans/"/>
    
  </entry>
  
  <entry>
    <title>Scrapy豆瓣搜索页爬虫</title>
    <link href="http://yoursite.com/2020/11/23/Scrapy%E8%B1%86%E7%93%A3%E6%90%9C%E7%B4%A2%E9%A1%B5%E7%88%AC%E8%99%AB/"/>
    <id>http://yoursite.com/2020/11/23/Scrapy%E8%B1%86%E7%93%A3%E6%90%9C%E7%B4%A2%E9%A1%B5%E7%88%AC%E8%99%AB/</id>
    <published>2020-11-23T10:07:22.000Z</published>
    <updated>2020-11-23T10:07:20.812Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Scrapy-豆瓣搜索页爬虫"><a href="#Scrapy-豆瓣搜索页爬虫" class="headerlink" title="Scrapy 豆瓣搜索页爬虫"></a>Scrapy 豆瓣搜索页爬虫</h1><p>使用scrapy爬虫框架对豆瓣图书搜索结果进行爬取</p><h2 id="Scrapy"><a href="#Scrapy" class="headerlink" title="Scrapy"></a>Scrapy</h2><p>Scrapy是一个为了爬取网站数据，提取结构性数据而编写的应用框架</p><p>可以应用在包括数据挖掘，信息处理或存储历史数据等一系列的程序</p><p>它提供了多种类型爬虫的基类，如BaseSpider、CrawlSpider等</p><h3 id="主要组件"><a href="#主要组件" class="headerlink" title="主要组件"></a>主要组件</h3><p>Scrapy框架主要由<strong>五大组件</strong>组成</p><ol><li><p><strong>调度器(Scheduler)</strong><br> 调度器，说白了把它假设成为一个URL的优先队列，由它来决定下一个要抓取的网址是什么，同时去除重复的网址，用户可以自己的需求定制调度器。</p></li><li><p><strong>下载器(Downloader)</strong><br> 下载器，是所有组件中负担最大的，它用于高速地下载网络上的资源<br> Scrapy的下载器代码不会太复杂，但效率高，主要的原因是Scrapy下载器是建立在twisted这个高效的        异步模型上的</p></li><li><p><strong>爬虫(Spider)</strong></p><p> 爬虫，是用户最关心的部份。用户定制自己的爬虫(通过定制正则表达式等语法)，用于从特定的网页中提取自己需要的信息，即所谓的实体(Item)。 用户也可以从中提取出链接,让Scrapy继续抓取下一个页面</p></li><li><p><strong>实体管道(Item Pipeline)</strong></p><p> 实体管道，用于处理爬虫(spider)提取的实体(Item)<br>主要的功能是持久化实体、验证实体的有效性、清除不需要的信息</p></li><li><p><strong>Scrapy引擎(Scrapy Engine)</strong></p><p> Scrapy引擎是整个框架的核心<br> 它用来控制调试器、下载器、爬虫。实际上，引擎相当于计算机的CPU,它控制着整个流程</p></li></ol><p><img src="https://img-blog.csdnimg.cn/20201123180151632.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyODE1ODA3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h3 id="数据流-Data-flow"><a href="#数据流-Data-flow" class="headerlink" title="数据流(Data flow)"></a>数据流(Data flow)</h3><p>Scrapy中的数据流由执行引擎控制，其过程如下:</p><ol><li>引擎打开一个网站，找到处理该网站的Spider并向该spider请求第一个要爬取的URL(s)</li><li>引擎从Spider中获取到第一个要爬取的URL并在调度器(Scheduler)以Request调度</li><li>引擎向调度器请求下一个要爬取的URL</li><li>调度器返回下一个要爬取的URL给引擎，引擎将URL通过下载中间件(request方向)转发给下载器(Downloader)</li><li>一旦页面下载完毕，下载器生成一个该页面的Response，并将其通过下载中间件(response方向)发送给引擎</li><li>引擎从下载器中接收到Response并通过Spider中间件(输入方向)发送给Spider处理</li><li>Spider处理Response并返回爬取到的Item及(跟进的)新的Request给引擎</li><li>引擎将(Spider返回的)爬取到的Item给Item Pipeline，将(Spider返回的)Request给调度器</li><li>(从第二步)重复直到调度器中没有更多地request，引擎关闭该网站</li></ol><h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><blockquote><p>创建项目    <code>scrapy startproject xxx</code><br>创建爬虫    <code>scrapy genspider xxx（爬虫名） xxx.com （爬取域）</code><br>生成文件    <code>scrapy crawl xxx -o xxx.json (生成json/csv文件)</code><br>运行爬虫    <code>scrapy crawl XXX</code><br>列出所有爬虫    <code>scrapy list</code></p></blockquote><h3 id="scrapy项目目录结构"><a href="#scrapy项目目录结构" class="headerlink" title="scrapy项目目录结构"></a>scrapy项目目录结构</h3><p>通过命令<code>scrapy startproject tutorial</code>创建一个新的项目<code>tutorial</code></p><p>将会创建包含下列内容的 <code>tutorial</code> 目录</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">tutorial/</span><br><span class="line">    scrapy.cfg    <span class="comment"># 项目的配置文件</span></span><br><span class="line">    tutorial/<span class="comment"># 该项目的python模块之后将在此加入代码</span></span><br><span class="line">        __init__.py</span><br><span class="line">        items.py<span class="comment"># 项目中的item文件</span></span><br><span class="line">        pipelines.py<span class="comment"># 项目中的pipelines文件</span></span><br><span class="line">        settings.py<span class="comment"># 项目的设置文件</span></span><br><span class="line">        spiders/<span class="comment"># 放置spider代码的目录</span></span><br><span class="line">            __init__.py</span><br><span class="line">            ...</span><br></pre></td></tr></table></figure><h2 id="使用scrapy爬取豆瓣搜索页"><a href="#使用scrapy爬取豆瓣搜索页" class="headerlink" title="使用scrapy爬取豆瓣搜索页"></a>使用scrapy爬取豆瓣搜索页</h2><p><strong>分析</strong></p><p><code>https://search.douban.com/movie/subject_search?search_text={search_text}&amp;cat=1002&amp;start={start}</code></p><p>search_text 搜索关键字</p><p>cat 搜索类别</p><p>start 开始的条数</p><p>url规则可以适用到图书电影搜索页面，后面的爬取也一样</p><p><strong>爬取后发现页面信息都无法获取</strong>，但是可以找到有个<code>window.__DATA__</code>猜测数据都被加密成了这串字符串<br><img src="https://img-blog.csdnimg.cn/20201123180017804.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyODE1ODA3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>一轮百度发现有大佬把加密的js代码提取出来了！</p><p>于是直接给出大佬的链接<a href="https://mp.weixin.qq.com/s/2mpu_oY2-M0wcLvf1eU7Sw" target="_blank" rel="noopener">豆瓣读书搜索页的window.<strong>DATA</strong>的解密</a></p><p>解决了这个问题其他的就很好爬取了</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>完整代码见<a href="https://github.com/MorreInfo/MoreInfo_Crawler/blob/master/moreinfo_crawler/spiders/douban_book_search.py" target="_blank" rel="noopener">github仓库</a></p><p>提取出的js在<code>third_party/main.js</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoubanBookSearchSpider</span><span class="params">(scrapy.Spider)</span>:</span></span><br><span class="line">    name = <span class="string">'douban_book_search'</span></span><br><span class="line">    allowed_domains = [<span class="string">'douban.com'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,keyword=None,start=None,*args, **kwargs)</span>:</span></span><br><span class="line">        super(DoubanBookSearchSpider, self).__init__(*args, **kwargs)</span><br><span class="line">        self.keyword = keyword</span><br><span class="line">        self.start = start</span><br><span class="line">        self.start_urls.append(<span class="string">f'https://search.douban.com/book/subject_search?search_text=<span class="subst">&#123;self.keyword&#125;</span>&amp;cat=1001&amp;start=<span class="subst">&#123;self.start&#125;</span>'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, response)</span>:</span></span><br><span class="line">        r = re.search(<span class="string">'window.__DATA__ = "([^"]+)"'</span>, response.text).group(<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 导入js</span></span><br><span class="line">        file_path = pathlib.Path.cwd() / <span class="string">'third_party/main.js'</span></span><br><span class="line">        <span class="keyword">with</span> open(file_path, <span class="string">'r'</span>, encoding=<span class="string">'gbk'</span>) <span class="keyword">as</span> f:</span><br><span class="line">            decrypt_js = f.read()</span><br><span class="line">        ctx = execjs.compile(decrypt_js)</span><br><span class="line">        data = ctx.call(<span class="string">'decrypt'</span>, r)</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> data[<span class="string">'payload'</span>][<span class="string">'items'</span>]:</span><br><span class="line">            <span class="keyword">if</span> item.get(<span class="string">'rating'</span>, <span class="literal">None</span>):</span><br><span class="line">                cover_url = item[<span class="string">'cover_url'</span>]</span><br><span class="line">                score = item[<span class="string">'rating'</span>][<span class="string">'value'</span>]</span><br><span class="line">                score_num = item[<span class="string">'rating'</span>][<span class="string">'count'</span>]</span><br><span class="line">                url = item[<span class="string">'url'</span>]</span><br><span class="line">                abstract = item[<span class="string">'abstract'</span>]</span><br><span class="line">                title = item[<span class="string">'title'</span>]</span><br><span class="line">                id = item[<span class="string">'id'</span>]</span><br><span class="line">                <span class="keyword">yield</span> DouBanBookSearchItem(</span><br><span class="line">                    cover_url=cover_url,</span><br><span class="line">                    score=score,</span><br><span class="line">                    score_num=score_num,</span><br><span class="line">                    url=url,</span><br><span class="line">                    abstract=abstract,</span><br><span class="line">                    title=title,</span><br><span class="line">                    id=id)</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.jianshu.com/p/cecb29c04cd2" target="_blank" rel="noopener">爬虫框架Scrapy个人总结（详细）熟悉</a></p><p><a href="https://scrapy-chs.readthedocs.io/zh_CN/0.24/topics/architecture.html" target="_blank" rel="noopener">架构概览</a></p><p><a href="https://blog.csdn.net/ck784101777/article/details/104468780/" target="_blank" rel="noopener">Scrapy爬虫框架，入门案例（非常详细）</a></p><p><a href="https://mp.weixin.qq.com/s/2mpu_oY2-M0wcLvf1eU7Sw" target="_blank" rel="noopener">豆瓣读书搜索页的window.<strong>DATA</strong>的解密</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Scrapy-豆瓣搜索页爬虫&quot;&gt;&lt;a href=&quot;#Scrapy-豆瓣搜索页爬虫&quot; class=&quot;headerlink&quot; title=&quot;Scrapy 豆瓣搜索页爬虫&quot;&gt;&lt;/a&gt;Scrapy 豆瓣搜索页爬虫&lt;/h1&gt;&lt;p&gt;使用scrapy爬虫框架对豆瓣图书搜索结果进
      
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="crawler" scheme="http://yoursite.com/tags/crawler/"/>
    
      <category term="Scrapy" scheme="http://yoursite.com/tags/Scrapy/"/>
    
  </entry>
  
</feed>
